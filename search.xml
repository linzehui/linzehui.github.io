<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深度炼丹tricks合集]]></title>
    <url>%2F2018%2F10%2F07%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%B7%B1%E5%BA%A6%E7%82%BC%E4%B8%B9tricks%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[长期更新。受知乎深度炼丹的启发，以及个人在实践过程和阅读中会接触到一些tricks，认为有必要做一个合集，将一些可能有用的tricks做记录。有实践过的会特别标注。 调参技巧数据增强预处理1️⃣zero-center[9]将数据中心化 初始化1️⃣Xavier initialization[7]方法适用[9]于普通激活函数(tanh,sigmoid)：scale = np.sqrt(3/n) 2️⃣He initialization[8]方法适用[9]于ReLU：scale = np.sqrt(6/n) 3️⃣Batch normalization[10]4️⃣RNN/LSTM init hidden stateHinton[3]提到将RNN/LSTM的初始hidden state设置为可学习的weight 训练技巧1️⃣Gradient Clipping[5,6]2️⃣learning rate原则：当validation loss开始上升时，减少学习率。[1]Time/Drop-based/Cyclical Learning Rate 3️⃣batch size[2]中详细论述了增加batch size而不是减小learning rate能够提升模型表现。保持学习率不变，提高batch size，直到batch size~训练集/10，接下来再采用学习率下降的策略。 Reference[1]How to make your model happy again — part 1 [2]Don’t Decay the Learning Rate, Increase the Batch Size [3]CSC2535 2013: Advanced Machine Learning Lecture 10 Recurrent neural networks [4]https://zhuanlan.zhihu.com/p/25110150 [5]On the difficulty of training Recurrent Neural Networks [6]Language Modeling with Gated Convolutional Networks [7]Understanding the difficulty of training deep feedforward neural networks [8]Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification [9]知乎：你有哪些deep learning（rnn、cnn）调参的经验？ [10]Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift]]></content>
      <tags>
        <tag>调参</tag>
        <tag>tricks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词11]]></title>
    <url>%2F2018%2F10%2F07%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D11%2F</url>
    <content type="text"><![CDATA[1️⃣赋得古原草送别[唐] 白居易离离原上草，一岁一枯荣。野火烧不尽，春风吹又生。远芳侵古道，晴翠接荒城。又送王孙去，萋萋满别情。 萋萋（qī）：形容草木长得茂盛的样子。 http://m.xichuangzhu.com/work/57b8a5371532bc005b99da51]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PRML第三章 回归的线性模型]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FPRML%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%9B%9E%E5%BD%92%E7%9A%84%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[线性基函数模型 偏置-⽅差分解 贝叶斯线性回归 贝叶斯模型⽐较 证据近似 —-未完—-]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>PRML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 16:SVM]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%2015%3A%20SVM%2F</url>
    <content type="text"><![CDATA[Hinge Loss+kernel method = SVM Hinge LossSVM与logistic regression的区别即在于loss function的不同，logistic是cross entropy，而SVM是hinge loss 也即如果分类间隔大于1，则 $L(m_i)=max(0,1−m_i(w))$，则损失为0。因此SVM更具鲁棒性，因为对离群点不敏感。 对于linear SVM： 定义函数 $f(x)=\sum_i w_i x_i +b=w^T x$ 定义损失函数 $L(f)=\sum_n l(f(x^n),\hat{y}^n)+\lambda ||w||_2$，其中$l(f(x^n),\hat{y}^n)=max(0,1-\hat{y}^n f(x))$ 梯度下降求解（省略了正则化） \frac{\partial{l(f(x^n),\hat{y}^n})}{\partial{w_i}}= \frac{\partial{l(f(x^n),\hat{y}^n})}{\partial{f(x^n)}} \frac{\partial{f(x^n)}}{\partial{w_i}} x_i^n 而 f(x^n)=w^T \cdot x^n \frac{\partial{max(0,1-\hat{y}^n f(x^n)})}{\partial{f(x^n)}}= \left\{ \begin{array}{**lr**} -\hat{y}^n & if \hat{y}^n f(x^n)]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 15:Transfer Learning]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%2015%3A%20Transfer%20Learning%2F</url>
    <content type="text"><![CDATA[Model Fine-tuning假设我们有很多的source data $(x^s,y^s )$，与任务相关的target data $(x^t,y^t )$ 很少。我们利用source data训练一个模型，然后用target data来fine tune模型。 conservative training 我们可以用source data训练好的模型的weight作为新的模型的weight，然后设定一些限制，比如source data作为输入的output应和target data作为输入的output尽量相似，或者参数尽量相似等。 layer transfer也就是新模型有几层是直接copy旧模型的，只训练其它层。注意到不同任务所应copy的层是不同的，语音任务最后几层效果好，图像识别前面几层效果好 Multitask Learning不同任务之间共享相同的中间层，如： 还有一种progressive neural networks：首先训练好第一个任务的模型，然后在训练第二个模型的时候将第一个模型的隐层加入到第二个模型的隐层中；训练第三个模型则将第二个和第一个模型的隐层加入到第三个模型的隐层中，以此类推 Domain-adversarial trainingsource data是有标签的，而target data是无标签的，都属于同一个任务，但数据是mismatch的，如： 因为NN的隐层可以理解成是在抽取图像的特征，我们希望能够在训练NN的过程中去掉source data的一些domain specific的特性，这样就可以用在target data上了。因此我们在feature exactor后面连接两个模块： 一方面我们希望抽取的特征能够使得分类器正确地分类，另一方面我们希望这些特征能够让domain classifier能够无法识别特征是从哪些data抽取得到的，这样得到的特征就是被去掉domain specific特征的。 具体训练： Zero-shot Learningsource data有标签，target data无标签，但任务不同，如： Representing each class by its attributes一种方法是将每一个类都用特征表示，但特征要足够丰富： 在训练的时候，输入是图片，输出则是这些特征：这样在将target data放入训练好的NN后也会得到一个这样的attribute，查表即可找到最相似的特征对应的类。 Attribute embedding如果特征维度太高，也可以将特征压缩成一个向量表示，这样在训练的时候，输出则是这样的向量特征，输入target data，输出向量特征，找到最近的特征对应的类即可 Attribute embedding + word embedding如果没有attribute数据，利用word embedding也可以达到不错的效果。在zero-shot learning中，光是让相同类的f和g相似是不够的，还应该让不同的f和g尽量远。 f^∗,g^∗=arg min_{(f,g)}⁡∑_nmax(0,k−f(x^n )\cdot g(y^n )+max_{(m≠n)} ⁡f(x^m )\cdot g(x^m ) )]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Transfer Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 14:Unsupervised Learning:Generation]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%2014%3A%20Unsupervised%20Learning%3A%20Generation%2F</url>
    <content type="text"><![CDATA[Component-by-component对于图像来说，每次生成一个pixel：PixelRNN VAE架构： 其中e是噪声，σ是方差，目标是最小化reconstruction error，以及一个限制。该限制的目的即防止σ=0，m是正则化项。 中间的推导以及为什么是这样的架构我还不是很懂，之后再更新。实际上可以这么理解，有几个要点： 首先我们是基于这么一个假设：中间的code应当是服从正态分布的，而encoder的作用即在于拟合该正态分布的均值与方差的对数（因为方差应当恒为正，但神经网络的输出可能有正有负） 如果生成出来的code不符合正态分布，会有一个惩罚项，也就是上图的constraint（可以通过KL散度推导获得） 按理说，应当是在生成了均值和方差后，定义好该正态分布，然后再从中采样，但是这样没办法回传更新梯度，因此这里使用重参数技巧(Reparameterization Trick)，也即从$N(\mu,\sigma^2)$中采样$Z$，相当于从$N(0,I)$中采样$\varepsilon$，然后让$Z=\mu + \varepsilon \times \mu$ Reference:https://www.sohu.com/a/226209674_500659 VAE的主要问题在于，网络只试图去记住见过的图像，但没法真正去生成没见过的图像。 Generative Adversarial Network (GAN)GAN包含一个discriminator和一个generator，generator试图生成能够骗过discriminator的样本，而generator试图能够将generator生成的样本和真实的样本区分。 之后会有详细的介绍。]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Unsupervised Learning</tag>
        <tag>Generation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 13:Unsupervised Learning:Auto-encoder]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%2013%3A%20Unsupervised%20Learning%3A%20Auto-encoder%2F</url>
    <content type="text"><![CDATA[Auto-encoder由一个encoder和一个decoder组成，encoder负责将输入转成一个向量表示（维度通常小于输入），decoder负责将这段向量表示恢复成原来的输入。那么中间的code就可以作为输入的一个低维表示： Auto-encoder for CNN Unpooling有两种方法，一种在pooling的时候记录最大值的位置，在unpooling时在相对位置填充最大值，其他位置填充0；另一种不记录最大值位置，直接在pooling区域全部填充最大值。 Deconvolution其实本质就是convolution。 这是convolution: 我们期待的convolution： 实际上就等价在两边做padding，然后直接convolution： Auto-encoder的用处可以预训练每一层的DNN： 同理其它层也是一样，每次fix住其他层然后做Auto-encoder。那么在bp的时候只需要fine-tune就行。]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Unsupervised Learning</tag>
        <tag>Auto-encoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 12:Unsupervised Learning:Neighbor Embedding]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%2012%3A%20Unsupervised%20Learning%3A%20Neighbor%20Embedding%2F</url>
    <content type="text"><![CDATA[Locally Linear Embedding (LLE)一种降维方法思想：假设每个点可以由其周围的点来表示 我们需要找到这样的$w_{ij}$，使得： ∑_i‖x^i−∑_j w_{ij} x^j ‖_2这样在降维的时候，我们仍然保持x之间的这样的关系: Laplacian Eigenmaps一种降维方法基本思想：如果$x^1$与$x^2$在高维空间中相近，则降维后也应该接近： S=1/2 ∑_{i,j} w_{i,j} (z^i−z^j )^2其中： 如果将z全设为0，显然S最小，因此我们需要给z一个限制：z应当充满空间，也即假如z是M维，那么$\{z^1,z^2…,z^N\}$的秩应该等于M T-distributed Stochastic Neighbor Embedding (t-SNE)也是一种降维方法前面提到的方法有一个问题：同一类的点确实聚在一起，但不同类的点并没有尽量分开 t-SNE的主要思想：将数据点映射到概率分布，我们希望降维前和降维后，数据分布的概率应当尽可能一致。t-SNE构建一个高维对象之间的概率分布，使得相似的对象有更高的概率被选择，而不相似的对象有较低的概率被选择。t-SNE在低维空间里在构建这些点的概率分布，使得这两个概率分布之间尽可能的相似。 如何做？在高维空间中，我们定义： P(x^j |x^i )=\frac{S(x^i,x^j )}{∑_{k≠i}S(x^i,x^k )}其中S表示i与j之间的相似度。 在低维空间中，同样有： Q(z^j |z^i )=\frac{S′(z^i,z^j )}{∑_{k≠i}S′(z^i,z^k )}使用KL散度去计算两个分布之间的差异： L=∑_i KL(P(∗|x^i )||Q(∗|z^i )) =∑_i∑_j P(x^j |x^i )\frac{log P(x^j |x^i )}{Q(z^j |z^i )}t-SNE中，高维空间和低维空间计算相似度的公式不大一样： S(x^i,x^j )=exp(−‖x^i−x^j ‖_2 )S′(z^i,z^j )=\frac{1}{(1+‖z^i−z^j ‖_2)}两个公式的图示： 也即低维空间会拉长距离，使得距离远的点尽可能被拉开。 t-SNE的问题在于：t-SNE无法对新的数据点进行降维。]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Unsupervised Learning</tag>
        <tag>Neighbor Embedding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 11:Unsupervised Learning:Linear Dimension Reduction]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%2011%3A%20Unsupervised%20Learning%3A%20Linear%20Dimension%20Reduction%2F</url>
    <content type="text"><![CDATA[ClusteringK-means算法步骤： 迭代更新使得最后聚类中心收敛。但事先需要定好有多少类。 Hierarchical Agglomerative Clustering (HAC)自下而上，每次选两个最近的聚为一类，直到所有的都分成一类最后选择一个阈值划分，如蓝色绿色和红色的线 Dimension Reduction找到一个映射，使得x能够映射到低维z Principle Component Analysis (PCA)目的是找到一个维度，使得投影得到的variance最大，也即最大程度保留数据的差异性。 形式化可以写成（一维情形）： Var(z_1 )=\frac{1}{N} ∑_{z_1}(z_1−\overline{z_1} )^2其中： ‖w^1 ‖_2=1z_1=w^1 \cdot x$\overline{z_1}$表示z的均值 假如我们要投影到多维，其他维度也有同样的目标。其中每个维度之间都应该是相互正交的。 如何做？找到$ \frac{1}{N}∑(x−\overline{x} ) (x−\overline{x})^T$的前k个最大的特征值对应的特征向量，组合起来即是我们要找的$W$ 证明—-Warning of Math—-目的：$Var(z_1 )=\frac{1}{N} ∑_{z_1}(z_1−\overline{z_1} )^2 $其中 $\overline{z_1} =\frac{1}{N} ∑{z_1} = \frac{1}{N} ∑ w^1 \cdot x=w^1\cdot \overline{x}$ 推导：改变符号 $S=Cov(x)$ 利用拉格朗日乘数法，有：$Sw^1=αw^1$等式两边各左乘$(w^1)^T$，有：$(w^1 )^T Sw^1=α(w^1 )^T w^1=α$ 也即，$α$是$S$的特征值，选择最大的特征值，就能够最大化我们的目标。 同理，我们要找$w^2$，最大化$(w^2 )^T Sw^2$，其中有：$(w^2 )^T w^2=1$$(w^2 )^T w^1=0$ （与第一维正交） 因此利用拉格朗日乘数法： g(w^2 )= (w^2 )^T Sw^2−α((w^2 )^T w^2−1)−β((w^2 )^T w^1−0)最终得到，w2对应第二大的特征值的特征向量。 以此类推，其他维也同理。—-End of Math—- PCA的其他实际上最终得到的z，每一维之间的协方差都为0 证明如下： PCA也可以用SVD来做： U中保存了K个特征向量。 从另一种角度理解PCA，也可以认为PCA是一种autoencoder： PCA的问题PCA是无监督学习，如果有标签，则无法按照类别来进行正确降维，如： 第二就是PCA是线性变换，对于一些需要非线性变换的无能为力 Matrix Factorization定义：矩阵分解，就是将一个矩阵D分解为U和V的乘积，即对于一个特定的规模为m*n的矩阵D，估计出规模分别为m*k和n*k的矩阵U和V，使得$UV^T$的值尽可能逼近矩阵D。常用于推荐系统。 思想：假如有一个矩阵： 假设横轴和纵轴每一维都有一个向量代表该维，矩阵的每个元素就是横轴和纵轴对应维的点积。我们的目的是尽可能减小： L=\sum_{(i,j)} (r^i \cdot r^j -n_{ij})^2其中$r_i$ $r_j$就是向量表示，$n_{ij}$就是矩阵的内容。 可以使用SVD求解上式： 实际上，考虑每一行或列本身的特性，我们对Loss进行扩展： Minimizing \ \ L=\sum_{(i,j)} (r^i \cdot r^j +b_i+b_j-n_{ij})^2使用SGD可以求解。]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Unsupervised Learning</tag>
        <tag>Linear Dimension Reduction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯度消失与梯度爆炸的推导]]></title>
    <url>%2F2018%2F10%2F07%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E4%B8%8E%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[记RNN中每一步的损失为$E_t$，则损失对$h_{t-1}$的权重$W$的导数有： \frac{\partial{E_t}}{\partial{W}}=\sum_{k=1}^{t} \frac{\partial{E_t}}{\partial{y_t}} \frac{\partial{y_t}}{\partial{h_t}} \frac{\partial{h_t}}{\partial{h_k}} \frac{\partial{h_k}}{\partial{W}}其中$\frac{\partial{h_t}}{\partial{h_k}}$使用链式法则有： \frac{\partial{h_t}}{\partial{h_k}} = \prod_{j=k+1}^{t} \frac{\partial{h_j}}{\partial{h_{j-1}}} = \prod_{j=k+1}^{t} W^T \times diag[f^{\prime}(h_{j-1})]其中$\frac{\partial{h_j}}{\partial{h_{j-1}}}$ 是雅克比矩阵。对其取模(norm)，有： \rVert \frac{\partial{h_j}}{\partial{h_{j-1}}}\rVert ≤ \rVert W^T \rVert \rVert diag[f^{\prime}(h_{j-1})] \rVert ≤ \beta_W \beta_h当$f$为sigmoid时，$f^{\prime}(h_{j-1})$最大值为1。 最终我们有： \rVert \frac{\partial{h_t}}{\partial{h_{k}}}\rVert ≤ \rVert \prod_{j=k+1}^{t} \frac{\partial{h_j}}{\partial{h_{j-1}}} \rVert ≤ (\beta_W \beta_h)^{t-k}从上式可以看出，当t-k足够大时，如果$(\beta_W \beta_h)$小于1则$(\beta_W \beta_h)^{t-k}$则会变得非常小，相反，若$(\beta_W \beta_h)$大于1则$(\beta_W \beta_h)^{t-k}$则会变得非常大。 在计算机中，当梯度值很大时，会造成上溢(NaN)，也即梯度爆炸问题，当梯度值很小时，会变成0，也即梯度消失。注意到，t-k的损失实际上评估的是一个较远的词对当前t的贡献，梯度消失也即意味着对当前的贡献消失。 Reference:CS224d: Deep Learning for NLP Lecture4]]></content>
      <tags>
        <tag>梯度消失</tag>
        <tag>梯度爆炸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识9]]></title>
    <url>%2F2018%2F10%2F07%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%8610%2F</url>
    <content type="text"><![CDATA[1️⃣[正态分布]高维正态分布是从一维发展而来的： https://www.zhihu.com/question/36339816 2️⃣[RNN]from https://www.cs.toronto.edu/~hinton/csc2535/notes/lec10new.pdf 通常而言，我们都会将RNN的initial state设为全0，但在Hinton的slide中提到，我们可以将初始状态作为可学习的变量，和我们在学习权重矩阵一样。]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>调参</tag>
        <tag>正态分布</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PRML第二章 概率分布]]></title>
    <url>%2F2018%2F09%2F30%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FPRML%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[二元变量 多项式分布 高斯分布 指数族分布 非参数优化]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>PRML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 10:Semi-supervised learning]]></title>
    <url>%2F2018%2F09%2F30%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%2010%3A%20Semi-supervised%2F</url>
    <content type="text"><![CDATA[什么是semi-supervised learning 给定数据${(x^r,\hat{y}^r)}_{r=1}^{R},{(x_u)}_{u=R}^{R+U}$，其中未标记数据远远多于标记数据 $U&gt;&gt;R$ 为什么半监督学习有用？因为未标记数据的分布可能能够给我们一些信息。 生成模型的半监督学习给定两类$C_1$、$C_2$，要求得到后验概率分布 P(C_1 |x)=\frac{P(x|C_1 )P(C_1 )}{(P(x|C_1 )P(C_1 )+P(x|C_2 )P(C_2 ) )}其中联合概率分布服从高斯分布。未标记数据此时的作用即帮我们重新估计$P(C_1),P(C_2),\mu,\Sigma$ 如何做?先初始化$P(C_1),P(C_2),\mu,\Sigma$，通常可以先用有标记数据进行估计 计算每个未标记数据的后验概率分布 以该概率分布更新模型不断重复直至拟合 原因：当我们在做监督学习时，使用最大似然求解： logL(θ)=∑_{x^r,\hat{y}^r} logP_θ (x^r |\hat{y}^r )加上了未标记数据后，同样也要做最大似然： logL(θ)=∑_{(x^r,\hat{y}^r)} logP_θ (x^r |\hat{y}^r )+∑_{x^u} logP_θ (x^u)Low-density Separation假设不同类别之间有一条明显的分界线，也即存在一个区域，其密度比其他区域小 Self-training如何做? 先用有标签数据训练一个模型$f$； 利用模型对未标记数据进行标记，这些标签称为伪标签（pseudo-label） 将部分有伪标签的数据放入有标签数据中，重新训练重复直到拟合 这种方式和生成模型的区别：该方法使用的是hard label而生成模型使用的是soft label Entropy-based Regularization将未标记数据充当正则化的效果，我们希望模型预测标签的概率较为集中，也即熵应该尽可能小。也就是说，未标记数据使得分类边界尽可能划在低密度区域。 Smoothness Assumption假设：位于稠密数据区域的两个距离很近的样例的类标签相似，通过high density path连接。 x1与x2之间较为稠密，因此x2与x1比x2与x3更为接近。 如何知道x1与x2通过high density path连接？ 基于图的方法： 定义xi与xj之间的相似度$s(x^i,x^j)$ 添加边，有两种选择 k nearest neighbor e-neighborhood 边之间的权重通过相似度来衡量。如： $s(x^i,x^j )=exp(−γ‖x^i−x^j‖^2)$ 该方法本质即利用有标签数据去影响未标记数据，通过图的传播。但一个问题是如果数据不够多，就可能没办法传播。如： 在建立好图后，如何使用? 定义图的平滑程度，$y$表示标签。$S$越小表示越平滑。S=1/2∑_{i,j} w_{i,j} (y^i−y^j )^2=y^T Lyy=[⋯y^i⋯y^j⋯]^TL=D−W D是邻接矩阵，第ij个元素即xi与xj之间的weight，W是对角矩阵，ii个元素是D的第i行的加和；L称为Graph Laplacian 我们最终在计算Loss的时候要加上这项正则项L=∑_{x^r}C(y^r,\hat{y}^r ) +λS]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>Semi-supervised learning</tag>
        <tag>李宏毅机器学习课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 7:Tips for DL]]></title>
    <url>%2F2018%2F09%2F30%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%207%3A%20Tips%20for%20DL%2F</url>
    <content type="text"><![CDATA[大纲 new activation function梯度消失问题：由于sigmoid会将值压缩，所以在反向传播时，越到后面值越小。 所以后层的更新会比前层的更新更快，导致前层还没converge，后层就根据前层的数据（random）达到converge了 ReLU能够快速计算，且能够解决梯度消失问题。 因为会有部分neuron的值是0，所以相当于每次训练一个瘦长的神经网络。 ReLU的变体 Maxout首先将几个neuron归为一组，然后每次前向传播时取最大的作为输出。 实际上ReLU是maxout的一种特殊形式： 更一般的，有： 因为w和b的变化，所以该activation function实际上就是一个learnable activation function 这样一个learnable activation function有这样的特点： Activation function in maxout network can be any piecewise linear convex functionHow many pieces depending on how many elements in a group 如： maxout应如何训练？ 实际上就是一个普通的瘦长network，常规训练即可。 Adaptive learning rate在adagrad中: 越到后面learning rate越来越小，但实际上在dl里面，error surface是非常复杂的，越来越小的learning rate可能不适用于dl。如： RMSprop$σ^t$是历史信息，也就是说$σ^t$参考了过去的梯度和当前的梯度获得一个新的放缩大小 Momentum引入惯性作为参考，也即参考了上一次梯度的方向。引入惯性后，可能有机会越过local minimum。普通的gradient descent:每次朝着梯度的反方向走。 Momentum: 考虑了上一步走的方向。 具体算法： Adam结合了RMSprop和Momentum，也即综合考虑了历史信息决定当前步长；考虑了上一步的方向决定当前走的方向。具体算法： Early Stopping就是在validation set的loss不再减小时停止 RegularizationL2正则化其中因此更新公式为： 也即每次以$1-\eta \lambda$对w进行放缩，使w更接近0正则化在DL中也称为weight decay L1正则化 则更新公式为： 也即每次以$ηλsgn(w)$ 使w往0靠（sgn表示符号函数） 可以看出，L1每次都加减相同的值，而L2按比例进行缩放。因此L1更为稀疏(sparse)。 Dropout训练的时候每一层采样p%的神经元设为0，让其不工作 实际上就是每个batch改变了网络结构，使得网络更细长 测试的时候所有的weight都乘以1-p% 从ensemble的角度看待dropout：在训练的时候训练一堆不同结构的network，最多有$2^N$种组合，N为neuron个数，可以称为终极的ensemble方法了。而在测试的时候对这些不同的网络进行平均。]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Tips for DL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[采样浅析]]></title>
    <url>%2F2018%2F09%2F30%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2F%E9%87%87%E6%A0%B7%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[总结在NLP中的采样方法（持续更新）。 采样方法1️⃣逆变换采样(Inverse Sampling)目的：已知任意概率分布的累积分布函数时，用于从该分布中生成随机样本。 —-什么是累积分布函数(CDF)—-是概率密度函数(PDF)的积分，定义： F_X(x)=P(X≤x)=\int_{-∞}^{x}f_X(t)dt—-END—- 想象我们知道高斯分布的概率密度函数，我们应该如何采样？本质上我们只能对均匀分布进行直接采样（高斯分布有算法可以生成采样，但无法一般化）。对于这种连续的随机变量，我们只能通过间接的方法进行采样。 逆变换采样即是通过累积分布函数的反函数来采样。因为累积分布函数的值域为$[0,1]$，因此我们通过在$[0,1]$上进行采样，再映射到原分布。例子:映射关系如图： 2️⃣重要性采样(Importance Sampling)目的：已知某个分布$P$，希望能估计$f(x)$的期望。亦即： E[f(x)]=\int_{x}f(x)p(x)dx≈\frac{1}{n}\sum_{i=1}^{n}f(x_i)其中$x\sim p$。假设$p(x)$的分布复杂或样本不好生成，另一分布$q(x)$方便生成样本。因此我们引入$q(x)$对原先分布进行估计。 E[f(x)]=\int_{x}f(x)p(x)dx=\int_{x}f(x)\frac{p(x)}{q(x)}q(x)dx≈\frac{1}{n}\sum_{i=1}^{n}f(x_i)\frac{p(x_i)}{q(x_i)}其中，$x \sim q$。$w(x)=\frac{p(x)}{q(x)}$称为Importance Weight 根据上式，实际上就是每次采样的加权求和。 Reference逆变换采样https://zh.wikipedia.org/wiki/%E9%80%86%E5%8F%98%E6%8D%A2%E9%87%87%E6%A0%B7 重要性采样https://www.youtube.com/watch?v=S3LAOZxGcnk ——持续更新——]]></content>
      <tags>
        <tag>采样</tag>
        <tag>sampling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识9]]></title>
    <url>%2F2018%2F09%2F30%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%869%2F</url>
    <content type="text"><![CDATA[1️⃣[Pytorch]Pytorch中保存checkpoint是一个dict形式，可以保存任意多个模型到一个checkpoint中。1234567import torch#savetorch.save(&#123; 'epoch': epoch, 'model_state_dict': model.state_dict(), 'optimizer_state_dict': optimizer.state_dict(), 'loss': loss, ... &#125;, PATH)#loadmodel = TheModelClass(*args, **kwargs) optimizer = TheOptimizerClass(*args, **kwargs)checkpoint = torch.load(PATH) model.load_state_dict(checkpoint['model_state_dict']) optimizer.load_state_dict(checkpoint['optimizer_state_dict']) epoch = checkpoint['epoch'] loss = checkpoint['loss']model.eval() # - or - model.train() 2️⃣[Pytorch]Pytorch可以load部分模型，也就是只load进来部分我们需要的层，这在transfer learning中用到。123torch.save(modelA.state_dict(), PATH)modelB = TheModelBClass(*args, **kwargs) modelB.load_state_dict(torch.load(PATH), strict=False)]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[no title]]></title>
    <url>%2F2018%2F09%2F30%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%9C%89%E5%8A%9B%E9%87%8F%E7%9A%84%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[每当我遇到自己不敢直视的困难时，我就会闭上双眼，想象自己是一个80岁的老人，为人生中曾放弃和逃避过的无数困难而懊悔不已，我会对自己说，能再年轻一次该有多好，然后我睁开眼睛：砰！我又年轻一次了！]]></content>
      <tags>
        <tag>佳句分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词10]]></title>
    <url>%2F2018%2F09%2F30%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D10%2F</url>
    <content type="text"><![CDATA[1️⃣次北固山下[唐] 王湾客路青山外，行舟绿水前。潮平两岸阔，风正一帆悬。海日生残夜，江春入旧年。乡书何处达，归雁洛阳边。 次：旅途中暂时停宿，这里是停泊的意思。 http://m.xichuangzhu.com/work/57b95de92e958a005fa8919e 2️⃣将赴吴兴登乐游原[唐] 杜牧清时有味是无能，闲爱孤云静爱僧。欲把一麾江海去，乐游原上望昭陵。 无能：无所作为。 http://m.xichuangzhu.com/work/57b99db9165abd005a6da742]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PRML第一章 绪论]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FPRML%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[记录PRML学习过程。笔记共享链接：https://1drv.ms/u/s!Apsp2510NHF6rIRjMclFB16v7B0FWg 概率论 决策论 信息论]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>PRML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 6:Backpropagation]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%206%3A%20Backpropagation%2F</url>
    <content type="text"><![CDATA[Chain Rule基本公式 forward pass和backward pass可以将backpropagation分为两步 forward pass在前向传播的时候提前计算/保存好，因为该梯度很简单 比如z对w1的梯度就是x1，就是和w1相连的项 backward pass回传的时候逐层相乘下去，类似动态规划，获得了后一层的梯度才能求出前一层的梯度。 总结 先前向，提前算出最邻近的梯度，直到output layer，计算完该梯度，再不断回传逐层相乘获得output对各层的梯度。 代码实现例子relu实现forward pass和backward pass1234567891011121314151617181920212223242526272829303132import torchclass MyReLU(torch.autograd.Function): """ We can implement our own custom autograd Functions by subclassing torch.autograd.Function and implementing the forward and backward passes which operate on Tensors. """ @staticmethod def forward(ctx, input): """ In the forward pass we receive a Tensor containing the input and return a Tensor containing the output. ctx is a context object that can be used to stash information for backward computation. You can cache arbitrary objects for use in the backward pass using the ctx.save_for_backward method. """ ctx.save_for_backward(input) #为了之后的backward计算 return input.clamp(min=0) @staticmethod def backward(ctx, grad_output): """ In the backward pass we receive a Tensor containing the gradient of the loss with respect to the output, and we need to compute the gradient of the loss with respect to the input. """ input, = ctx.saved_tensors grad_input = grad_output.clone() grad_input[input &lt; 0] = 0 return grad_input]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Backpropagation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 5:Classification:Logistic Regression]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%205%20Classification%3A%20Logistic%20Regression%2F</url>
    <content type="text"><![CDATA[logistic regression如何做？step1: 定义function set step2: 更新使用最大似然更新 L(w,b)=f_{w,b}(x^1 )f_{w,b}(x^2 )(1−f_{w,b} (x^3 ))⋯f_{w,b} (x^N )找到w，b使得L最大 对似然函数取负对数，则有： 将式子的每个元素写成伯努利分布形式： 上式就是cross-entropy损失函数。 求导该式子可得：更新公式：可以看出上式很直观：和答案差距越大，更新步伐越大。 同时发现上式和linear regression的更新公式是一致的。 为什么不像linear regression那样设loss为square？假设我们使用square loss，则求导得到的梯度：上式可以看出，当接近target时，梯度小；远离target时，梯度也小。难以达到全局最小 下图是cross entropy和square error的图像示意： 如图，square loss难以到达全局最小。 生成式模型与判别式模型的区别生成式对联合概率分布进行建模，再通过贝叶斯定理获得后验概率；而判别式模型直接对后验概率建模。二者所定义的function set是一致的，但同一组数据可能会得到不同的w和b。 二者优劣对比： 数据量多时，一般来说判别式模型会更好。因为判别式模型没有先验假设，完全依赖于数据。但如果数据有噪声，容易受影响。 生成式模型是有一定的假设的，当假设错误，会影响分类效果。 正因为有一定的先验假设，当数据量很少时，可能效果会不错；对于噪声更具有鲁棒性。 先验可以从其他数据源获得来帮助特定任务，如语音识别问题。 logistic的局限本质仍是一个线性分类器，没办法分类非线性的数据。如何解决该问题?将logistic regression model拼接起来，前面的model对数据进行feature transformation，然后再对新的feature进行分类。 logistic与deep learning的联系：如果将logistic regression的一个单元称为neuron，拼起来就是neural network了！！！]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Classification</tag>
        <tag>Logistic Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识8]]></title>
    <url>%2F2018%2F09%2F23%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%868%2F</url>
    <content type="text"><![CDATA[1️⃣[Pytorch]torch.max()有两种不同写法。torch.max(input) → Tensor 返回其中最大的元素torch.max(input, dim, keepdim=False, out=None) → (Tensor, LongTensor) 返回该维度上最大值，以及对应的index 2️⃣[Pytorch]将模型同时部署到多张卡上训练，本质就是将一个batch的数据split，送到各个model，然后合并结果。 123456model = nn.DataParallel(model)device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")model.to(device)for data in rand_loader: input = data.to(device) output = model(input) 3️⃣[求导]标量、向量、矩阵之间的求导有两种布局，即分子布局和分母布局。分子布局和分母布局只差一个转置。我的记法：在求导过程中，假设分母为m*n，分子为 k*n，则导数矩阵应该为 k*m 。一些特殊的如标量对矩阵求导等除外。具体直接查表：https://en.m.wikipedia.org/wiki/Matrix_calculus 按位计算求导：假设一个函数$f(x)$的输入是标量$x$。对于一组K个标量$x_1,··· ,x_K$，我们可以通过$f(x)$得到另外一组K个标量$z_1,··· ,z_K$，$z_k = f(x_k),∀k = 1,··· ,K$其中，$f(x)$是按位运算的，即$[f(x)]_i = f(x_i)$其导数是一个对角矩阵： Reference：https://en.m.wikipedia.org/wiki/Matrix_calculushttps://blog.csdn.net/uncle_gy/article/details/78879131https://nndl.github.io/chap-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80.pdf]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Pytorch</tag>
        <tag>求导</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段记录7]]></title>
    <url>%2F2018%2F09%2F23%2F%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%2F%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%957%2F</url>
    <content type="text"><![CDATA[1️⃣softmax的numpy实现123def softmax(x,axis=0): """Compute softmax values for each sets of scores in x.""" return np.exp(x) / np.sum(np.exp(x), axis=axis) 2️⃣numpy 手动求导relu123456789101112131415161718192021222324252627282930313233343536import numpy as np# N is batch size; D_in is input dimension;# H is hidden dimension; D_out is output dimension.N, D_in, H, D_out = 64, 1000, 100, 10# Create random input and output datax = np.random.randn(N, D_in)y = np.random.randn(N, D_out)# Randomly initialize weightsw1 = np.random.randn(D_in, H)w2 = np.random.randn(H, D_out)learning_rate = 1e-6for t in range(500): # Forward pass: compute predicted y h = x.dot(w1) h_relu = np.maximum(h, 0) y_pred = h_relu.dot(w2) # Compute and print loss loss = np.square(y_pred - y).sum() print(t, loss) # Backprop to compute gradients of w1 and w2 with respect to loss grad_y_pred = 2.0 * (y_pred - y) grad_w2 = h_relu.T.dot(grad_y_pred) grad_h_relu = grad_y_pred.dot(w2.T) grad_h = grad_h_relu.copy() grad_h[h &lt; 0] = 0 grad_w1 = x.T.dot(grad_h) # Update weights w1 -= learning_rate * grad_w1 w2 -= learning_rate * grad_w2 3️⃣Pytorch实现relu1234567891011121314151617181920212223242526272829303132import torchclass MyReLU(torch.autograd.Function): """ We can implement our own custom autograd Functions by subclassing torch.autograd.Function and implementing the forward and backward passes which operate on Tensors. """ @staticmethod def forward(ctx, input): """ In the forward pass we receive a Tensor containing the input and return a Tensor containing the output. ctx is a context object that can be used to stash information for backward computation. You can cache arbitrary objects for use in the backward pass using the ctx.save_for_backward method. """ ctx.save_for_backward(input) #为了之后的backward计算 return input.clamp(min=0) @staticmethod def backward(ctx, grad_output): """ In the backward pass we receive a Tensor containing the gradient of the loss with respect to the output, and we need to compute the gradient of the loss with respect to the input. """ input, = ctx.saved_tensors grad_input = grad_output.clone() grad_input[input &lt; 0] = 0 return grad_input 4️⃣Pytorch在多张卡上部署123456model = nn.DataParallel(model)device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")model.to(device)for data in rand_loader: input = data.to(device) output = model(input)]]></content>
      <tags>
        <tag>code snippets</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听达观杯现场答辩有感]]></title>
    <url>%2F2018%2F09%2F19%2F%E8%A7%81%E9%97%BB%26%E6%83%B3%E6%B3%95%2F%E5%90%AC%E8%BE%BE%E8%A7%82%E6%9D%AF%E7%8E%B0%E5%9C%BA%E7%AD%94%E8%BE%A9%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[前几日（周日）去了达观杯答辩现场听了前10名做了报告，有了一些感想，但一直没有抽出时间写一下自己的感想（懒）。 自己大概花了十来天做了一下比赛，实际上也就是一个文本分类的比赛，因为没有比赛经验的缘故，走了很多弯路。不过也学到了一些东西。 现记录前十名的一些idea/trick： 数据增强 因为给的句子长度很长，因此在做截断的时候后面的就没法训练到了，可以将文本倒序作为新的数据训练模型。可以充分利用到数据 将数据打乱、随机删除，实际上就是对一个句子的词进行sample再组合 打乱词序以增加数据量 使用pseudo labeling，但有的队伍使用这个做出效果了，但有的没有 特征工程 假设开头中间结尾的信息对分类有帮助，因此截取该部分信息做训练 改进baseline的tfidf的特征工程方法，使用基于熵的词权重计算 降维，留下最重要的特征。先用卡方分布降到20万，再用SVD降到8000 将word2vec和GloVe拼接起来作为deep learning模型的输入 将文章分段，每段取前20后20拼起来 模型融合 所有队伍都无一例外使用了模型融合，stacking或者简单的投票 DL+ML —&gt; lgbm model —&gt; voting 深度模型+传统模型，在深度模型最后一层加入传统模型的信息/feature 后向选择剔除冗余模型 DL&amp;其他 HAN，选择10个attention vector 对易错类增加权重，通过改变损失函数来增加权重 CNN, [1,2,3,4,5,6]*600 提出新的模型（第一名） 其实除了一些trick，我还是有些失望的，因为都是用模型融合堆出来的，这也让我对比赛失去了一些兴趣。虽然能理解现在的比赛都是这样的，但感觉实在太暴力了。当然，其中还是有一些亮点的，有一支队伍立意很高，从理解业务的角度出发而不是堆模型，也取得了很好的效果；还有一个使用了最新论文中的特征工程改进方法，令我耳目一新；以及第一名在比赛过程中提出来三个新的模型。 Anyway，我目前还是太菜了，还是安心搞科研吧。_(:з」∠)]]></content>
      <tags>
        <tag>有感</tag>
        <tag>达观杯</tag>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识7]]></title>
    <url>%2F2018%2F09%2F16%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%867%2F</url>
    <content type="text"><![CDATA[1️⃣[Pytorch]只有一个元素的tensor，可用.item()来获取元素 tensor &lt;—&gt; numpy 相互转化会共享内部数据，因此改变其中一个会改变另一个 可用使用 .to 来移动到设备 .detech() detach it from the computation history, and to prevent future computation from being tracked. 将其从计算图中分离，变为叶子节点，并且requires_grad=False Function 记录了这个tensor是怎么来的，所有的tensor都有，除非是用户自定义的： 2️⃣[协方差]关于协方差的理解，x与y关于某个自变量的变化程度，即度量了x与y之间的联系。https://www.zhihu.com/question/20852004]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Pytorch</tag>
        <tag>协方差</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 4:Classification:Probabilistic Generative Model]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%204%20Classification%20%20Probabilistic%20Generative%20Model%2F</url>
    <content type="text"><![CDATA[为什么不使用regression来分类？1️⃣如果使用regression的思想来分类，会对离边界较远的点进行惩罚： 2️⃣如果多分类使用regression，如class 1, class 2, class 3；则隐式地假设了class 1 和 class 2较为接近，如果没有这种接近关系，则分类会不正确。 问题描述与定义 当P大于0.5则是C1类，反之是C2类先验P(C1)和P(C2)都好计算，计算C1占总的比例即可因此，我们需要计算的就是p(x|C) 这一想法，本质是得到了生成式模型： 原理概述现假设训练数据点的分布服从高斯分布：（显然可以自己设任何分布）即数据从高斯分布采样得到： 根据最大似然估计，可以获得每个类别的μ和Σ： 得到了参数后，即可代入得到P(C|x) ： 刚刚假设$Σ$对于不同类别不同，现我们令不同类别共享相同$Σ$：（因为协方差代表的是不同feature之间的联系，可以认为是和类别无关的） $Σ$的计算公式是加权求和： 在使用了相同的协方差矩阵后，边界就是线性的（后面会提到为什么是这样）： 总结： 三步走，定义function set，计算μ和协方差矩阵，得到best function： 注意到，如果我们认为，不同feature之间没有关系，每个feature符合特定的高斯分布，则该分类器则是朴素贝叶斯分类器： 分类与logistics regression现推导，该分类问题与logistics regression之间的联系：即： 假设数据服从高斯分布，共享$Σ$ 推导①总框架： 令 则有： ②z的进一步推导与简化： 将z展开： 而第一部分有： 第一部分相除，有： 再进行展开，有： 最终z的公式为： 由于共享协方差矩阵，则可以消去部分，得到： 替换成w和b： ③最终，将z带回到原式： 所以我们不需要再估计N1,N2,μ和Σ，直接计算w和b即可。也因此，分界线是线性的。 全过程：]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Classification</tag>
        <tag>Probabilistic Generative Model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 3:Gradient Descent]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%203%20Gradient%20Descent%2F</url>
    <content type="text"><![CDATA[Gradient Descent tipstip 1：Adaptive Learning RatesAdagrad基本思想 其中σ是之前所有的梯度的平方根 化简形式： 为什么要怎么做？考虑一个开口向上的二次函数 也即，最好的步长是一次导除以二次导，但二次导计算量大，因此使用近似的方式：对一次导作多次的sample。下图显示，如果二次导小，那么多次sample获得的一次导也小，反之则大，也就是说，一次导在某种程度上可以反映二次导的大小，所以直接用一次导近似，可以减少计算量。 tip 2：feature scaling 能够改变loss的分布，上图1中w2对loss的影响较大，则较陡峭，参数更新就较困难，需要adaptive learning rate；如果进行feature scaling，能够更好达到local optimal Gradient Descent Theory另一种角度看gradient descent： 基本思想：我们希望每一次都在当前点附近找到一个最小的点，即在一个范围内： 应该如何找到该最小点？ 我们知道，泰勒级数的形式： 当x接近x0时，会有如下近似： 推广到多元泰勒级数则有： 那么，如前所述，x接近x0，对于图中，即圆圈足够小时： 简化符号： 所以可以简写成： 由于s,u,v都是常数，在圆圈范围内寻找最小值对应的参数可以简化成： 再度简化，可以表达成： 在图中可以画为两个向量的点积 显然，当反方向时，最小： 也即： 最终完整的式子： 因此，当learning rate不够小时，是不满足泰勒级数近似的。]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>Gradient Descent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 2:Bias and Variance]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%2FLecture%202%20Bias%20and%20Variance%2F</url>
    <content type="text"><![CDATA[如何理解bias&amp;variancebias是function space中心离optimal model的差距，variance是某次实验所得模型离function space中心的距离。 比如说，简单地模型的function space小，随机性小，因此variance小，但也因为function space小，表示能力有限，因此bias大。 如图：该图中蓝色圈代表模型所能表达的范围。 如何解决variance大的问题①更多的data②regularization：强迫function更平滑，因此减小variance，但因为调整了function space，可能会增加bias。]]></content>
      <tags>
        <tag>机器学习🤖</tag>
        <tag>李宏毅机器学习课程</tag>
        <tag>bias&amp;variance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词9]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D9%2F</url>
    <content type="text"><![CDATA[白雪歌送武判官归京[唐] 岑参北风卷地白草折，胡天八月即飞雪。忽如一夜春风来，千树万树梨花开。散入珠帘湿罗幕，狐裘不暖锦衾薄。将军角弓不得控，都护铁衣冷难着。瀚海阑干百丈冰，愁云惨淡万里凝。中军置酒饮归客，胡琴琵琶与羌笛。纷纷暮雪下辕门，风掣红旗冻不翻。轮台东门送君去，去时雪满天山路。山回路转不见君，雪上空留马行处。 http://m.xichuangzhu.com/work/57b903e3d342d3005ac74290 绝命诗谭嗣同望门投止思张俭，忍死须臾待杜根。我自横刀向天笑，去留肝胆两昆仑！]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch backward()浅析]]></title>
    <url>%2F2018%2F09%2F16%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2FPytorch%20backward()%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[最近在看pytorch文档的时候，看到backward内有一个参数gradient，在经过查阅了相关资料和进行了实验后，对backward有了更深的认识。 backward1️⃣如果调用backward的是一个标量，如：loss.backward()则gradient不需要手动传入，会自动求导。例子:$a=[x_1,x_2],b=\frac{x_1+x_2}{2}$则b对a求导，有：$\dfrac {\partial b}{\partial x_{1}}=\frac{1}{2}，\dfrac {\partial b}{\partial x_{2}}=\frac{1}{2}$ 123456import torcha=torch.Tensor([2,3])a.requires_grad=Trueb=torch.mean(a) #tensor(2.5000, grad_fn=&lt;MeanBackward1&gt;)b.backward()a.grad #tensor([0.5000, 0.5000]) gradient此时只是在缩放原grad的大小，也即不指定gradient和gradient=1是等价的 当然，也可以指定gradient，其中指定gradient的shape必须和b的维度相同123gradient=torch.tensor(10.0)b.backward(gradient)a.grad #tensor([5., 5.]) 2️⃣如果调用backward的是一个向量例子：$a=[x_1,x_2],b=[b_1,b_2]$, 其中 $b_1=x_1+x_2,b_2=x_1*x_2$b对a求导，有：$\dfrac {\partial b_1}{\partial x_{1}}=1,\dfrac {\partial b_1}{\partial x_{2}}=1$ $\dfrac {\partial b_2}{\partial x_{1}}=x_2,\dfrac {\partial b_2}{\partial x_{2}}=x_1$ 在backward的时候则必须指定gradient。 1234567891011121314151617181920import torcha=torch.FloatTensor([2,3])a.requires_grad=Trueb=torch.zeros(2)b[0]=a[0]+a[1]b[1]=a[0]*a[1] # b=tensor([5., 6.], grad_fn=&lt;CopySlices&gt;)gradient=torch.tensor([1.0,0.0])b.backward(gradient,retain_graph=True)a.grad #tensor([1., 1.])，说明是对b_1进行求导a.grad.zero_() #将梯度清空，否则会叠加#-------------- #gradient=torch.tensor([0.0,1.0])b.backward(gradient,retain_graph=True)a.grad # tensor([3., 2.])，说明对b_2进行求导a.grad.zero_()# ------------- #gradient=torch.tensor([1.0,1.0])b.backward(gradient,retain_graph=True)a.grad # tensor([4., 3.])，即b_1,b_2的导数的叠加a.grad.zero_() 注意到b.backward()时需要retain_graph设为True，否则在计算完后会自动释放计算图的内存，这样就没法进行二次反向传播了。 Referencehttps://www.pytorchtutorial.com/pytorch-backward/]]></content>
      <tags>
        <tag>Pytorch</tag>
        <tag>backward</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词8]]></title>
    <url>%2F2018%2F09%2F09%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D8%2F</url>
    <content type="text"><![CDATA[望月怀远[唐] 张九龄海上生明月，天涯共此时。情人怨遥夜，竟夕起相思。灭烛怜光满，披衣觉露滋。不堪盈手赠，还寝梦佳期。 遥夜，长夜。 http://m.xichuangzhu.com/work/57aca120a341310060e2a09f 无题萨镇冰五十七载犹如梦，举国沦亡缘汉城。龙游浅水勿自弃，终有扬眉吐气天。 1951年，中国人民志愿军在抗美援朝战争第三次战役后打进了汉城，萨镇冰得知此事，回想起57年前的甲午悲歌，当即作诗一首。 白雪歌送武判官归京[唐] 岑参北风卷地白草折，胡天八月即飞雪。忽如一夜春风来，千树万树梨花开。散入珠帘湿罗幕，狐裘不暖锦衾薄。将军角弓不得控，都护铁衣冷难着。瀚海阑干百丈冰，愁云惨淡万里凝。中军置酒饮归客，胡琴琵琶与羌笛。纷纷暮雪下辕门，风掣红旗冻不翻。轮台东门送君去，去时雪满天山路。山回路转不见君，雪上空留马行处。 http://m.xichuangzhu.com/work/57b903e3d342d3005ac74290]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词7]]></title>
    <url>%2F2018%2F09%2F02%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D7%2F</url>
    <content type="text"><![CDATA[滕王阁序遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人；萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？ 注释：遥襟甫畅，逸兴遄（chuán）飞：登高望远的胸怀顿时舒畅，飘欲脱俗的兴致油然而生。 爽籁（lài）发而清风生，纤歌凝而白云遏：宴会上，排箫响起，好像清风拂来；柔美的歌声缭绕不散，遏止了白云飞动。爽：形容籁的发音清脆。籁：排箫，一种由多根竹管编排而成的管乐器。 睢（suī）园绿竹，气凌彭泽之樽：今日的宴会，好比当年睢园竹林的聚会，在座的文人雅士，豪爽善饮的气概超过了陶渊明。睢园：西汉梁孝王在睢水旁修建的竹园，他常和一些文人在此饮酒赋诗。 邺（yè）水朱华，光照临川之笔：这是借诗人曹植、谢灵运来比拟参加宴会的文人。邺：今河北临漳，是曹魏兴起的地方。曹植曾在这里作过《公宴诗》，诗中有“朱华冒绿池”的句子。临川之笔：指谢灵运，他曾任临川（今属江西）内史。 四美：指良辰、美景、赏心、乐事。 二难：贤主、嘉宾。 地势极而南溟深，天柱高而北辰远：地势偏远，南海深邃；天柱高耸，北极星远悬。 帝阍（hūn）：原指天帝的守门者。这里指皇帝的宫门。 奉宣室以何年：什么时候才能像贾谊那样去侍奉君王呢]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识6]]></title>
    <url>%2F2018%2F09%2F02%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%866%2F</url>
    <content type="text"><![CDATA[1️⃣[dropout]dropout形式:RNN的形式有多种： recurrent dropoutRNN: $h_t=f(W_h ⊙ [x_t,h_{t-1}]+b_h)$加上dropout的RNN：$h_t=f(W_h ⊙ [x_t,d(h_{t-1})]+b_h)$，其中$d(\cdot)$为dropout函数同理：LSTM:$c_t=f_t ⊙c_{t-1} + i_t ⊙ d(g_t)$GRU:$h_t=(1-z_t)⊙c_{t-1}+z_t⊙d(g_t)$ 垂直连接的dropoutdropout的作用即是否允许L层某个LSTM单元的隐状态信息流入L+1层对应单元。 Reference:https://blog.csdn.net/falianghuang/article/details/72910161 2️⃣[Pytorch]pack_padded_sequence用于RNN中，将padding矩阵压缩:这样就可以实现在RNN传输过程中短句提前结束。 pad_packed_sequence是pack_padded_sequence的逆运算。]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Pytorch</tag>
        <tag>dropout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我没有说话]]></title>
    <url>%2F2018%2F08%2F29%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%88%91%E6%B2%A1%E6%9C%89%E8%AF%B4%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[《我没有说话》 纳粹杀共产党时，我没有出声——因为我不是共产党员；接着他们迫害犹太人，我没有出声——因为我不是犹太人；然后他们杀工会成员，我没有出声——因为我不是工会成员；后来他们迫害天主教徒，我没有出声——因为我是新教徒；最后当他们开始对付我的时候，已经没有人能站出来为我发声了]]></content>
      <tags>
        <tag>佳句分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deep Learning NLP best practices笔记]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2FDeep%20Learning%20NLP%20best%20practices%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[博客地址：http://ruder.io/deep-learning-nlp-best-practices/index.html个人觉得这篇文章写得很好，有许多实践得到的经验，通过这篇可以避免走一些弯路。 PracticesWord Embedding The optimal dimensionality of word embeddings is mostly task-dependent: a smaller dimensionality works better for more syntactic tasks such as named entity recognition or part-of-speech (POS) tagging, while a larger dimensionality is more useful for more semantic tasks such as sentiment analysis. 对于偏向语法的，使用维度低一些的词向量；而对于偏向语义内容的，使用维度大一些的词向量，如情感分析。 LSTM Depth performance improvements of making the model deeper than 2 layers are minimal LSTM深度最好不要超过两层。 Optimization It is often thought that Adam clearly outperforms vanilla stochastic gradient descent (SGD). However, while it converges much faster than SGD, it has been observed that SGD with learning rate annealing slightly outperforms Adam. Recent work furthermore shows that SGD with properly tuned momentum outperforms Adam . Adam可以更早拟合，而SGD效果可能会更好一些。 可以采用优化策略，比如说使用Adam训练直到拟合，然后将学习率减半，并重新导入之前训练好的最好的模型。这样Adam能够忘记之前的信息并重新开始训练。 Denkowski &amp; Neubig (2017) show that Adam with 2 restarts and learning rate annealing is faster and performs better than SGD with annealing Ensembling Combining multiple models into an ensemble by averaging their predictions is a proven strategy to improve model performance. Ensembling很重要的一点是需要保证多样性： Ensembling is an important way to ensure that results are still reliable if the diversity of the evaluated models increases (Denkowski &amp; Neubig, 2017). While ensembling different checkpoints of a model has been shown to be effective (Jean et al., 2015; Sennrich et al., 2016) [51, 52], it comes at the cost of model diversity. Cyclical learning rates can help to mitigate this effect LSTM tricks 在initial state中我们常常使用全0向量，实际上可以将其作为参数学习。 Instead of fixing the initial state, we can learn it like any other parameter, which can improve performance 将input和output embedding的参数共享，如果是做language model或者机器翻译之类的，可以让他们共享。 Gradient Norm Clipping Rather than clipping each gradient independently, clipping the global norm of the gradient yields more significant improvements 这点我没看懂。 Classification practices关于CNN CNN filters:Combining filter sizes near the optimal filter size, e.g. (3,4,5) performs best (Kim, 2014; Kim et al., 2016). The optimal number of feature maps is in the range of 50-600 (Zhang &amp; Wallace, 2015) [59]. Aggregation function:1-max-pooling outperforms average-pooling and k-max pooling (Zhang &amp; Wallace, 2015). 这在我之前的关于CNN文本分类指南中有更详尽的分析。 Conclusion这是一篇干货满满的博客，实际上我还是有许多地方没有读懂，这适合多看几遍，慢慢理解。]]></content>
      <tags>
        <tag>NLP🤖</tag>
        <tag>笔记📒</tag>
        <tag>指南</tag>
        <tag>调参</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识5]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%865%2F</url>
    <content type="text"><![CDATA[1️⃣[Paper]Joint Embeddings of Chinese Words, Characters, and Fine-grained Subcharacter Components 基本框架和CBOW一致，主要贡献在于针对中文词向量添加了偏旁、字的组件作为训练信息。 2️⃣[Paper]Highway Networks 为了解决神经网络深度过深时导致的反向传播困难的问题。前向传播的公式： y=H(x,W_H)而论文所做的改进： y=H(x,W_H) \cdot T(x,W_T)+ x \cdot C(x,W_C)其中$T$是transform gate，$C$是carry gate。方便起见，可以将 $C=1-T$，最终有： y=H(x,W_H) \cdot T(x,W_T)+ x \cdot (1-T(x,W_T))可以看出思想和LSTM很类似，都是gate的思想。 3️⃣[调参方法]博客：https://blog.goodaudience.com/how-to-make-your-model-happy-again-part-1-40d94a9ffb41 学习率： 一条原则：当validation loss开始上升时，减少学习率。 如何减少？ 或者： 设定一定的epoch作为一个stepsize，在训练过程中线性增加学习率，然后在到达最大值后再线性减小。实验表明，使用该方法可以在一半的epoch内达到相同的效果。 batch size： 由于batch size和学习率的强相关性，相关论文提出提高batch size而不是降低学习率的方法来提升模型表现。 increasing the batch size during training, instead of decaying learning rate. — L. Smithhttps://arxiv.org/pdf/1711.00489.pdf 一个trick：保持学习率不变，提高batch size，直到batch size~训练集/10，接下来再采用学习率下降的策略。]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Paper</tag>
        <tag>调参方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段记录6]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%2F%E4%BB%A3%E7%A0%81%E5%88%86%E4%BA%AB6%2F</url>
    <content type="text"><![CDATA[1️⃣将数据整理成batch123456789101112131415161718192021def _iter_batch(paras,labels,batch_size,shuffle=True): ''' :param paras: :param labels: :param batch_size: :param shuffle: :return: ''' assert len(paras)==len(labels) paras_size=len(paras) if shuffle: indices=np.arange(paras_size) np.random.shuffle(indices) for start_idx in range(0,paras_size-batch_size+1,batch_size): if shuffle: excerpt=indices[start_idx:start_idx+batch_size] else: excerpt=slice(start_idx,start_idx+batch_size) yield paras[excerpt],labels[excerpt]]]></content>
      <tags>
        <tag>code snippets</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词6]]></title>
    <url>%2F2018%2F08%2F26%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D6%2F</url>
    <content type="text"><![CDATA[1️⃣ 戏为六绝句[唐] 杜甫【其二】王杨卢骆当时体，轻薄为文哂未休。尔曹身与名俱灭，不废江河万古流。 哂（shěn）：讥笑。 http://m.xichuangzhu.com/work/57b9658c0a2b58005c95d2a7]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CNN文本分类任务指南]]></title>
    <url>%2F2018%2F08%2F25%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2FCNN%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[最近因为比赛的缘故对文本分类有一定的了解。其中使用CNN方法做情感分析任务存在着许多优势。虽然模型简单，但如何设置超参有时候对结果有很大的影响。本文记录了关于CNN文本分类的一些学习历程和指南，基本参考了论文。 做法基本上目前较为浅层的CNN文本分类的做法都是如下图： 将词向量堆积成为二维的矩阵，通过CNN的卷积单元对矩阵进行卷积处理，同时使用pooling（通常是1max-pooling）操作，将不等长的卷积结果变为等长，对不同的卷积单元的结果进行拼接后生成单个向量，最后再通过线性层转化成类别概率分布。 另一张图也说明了该流程。 建议与指导超参及其对结果的影响接下来的内容参考了论文A Sensitivity Analysis of (and Practitioners’ Guide to) ConvolutionalNeural Networks for Sentence Classification CNN文本分类的超参： 输入向量 卷积大小 输出通道（feature maps） 激活函数 池化策略 正则化 输入向量的影响实验表明，使用word2vec和GloVe不分伯仲，但将word2vec和GloVe简单拼接在一起并不能带来提升。 unfortunately, simply concatenating these representations does necessarily seem helpful 当句子长度很长（document classification）时，使用one-hot可能会有效果，但在句子长度不是很长时，效果不好。 建议对于新任务，可以word2vec或GloVe或者其他词向量都试一下，如果句子长，可以试着使用one-hot。 卷积大小由于卷积的长度是固定的，也就是词向量的长度，因此只需讨论宽度。实验表明，不同的数据集会有不同的最佳大小，但似乎对于长度越长的句子，最佳大小有越大的趋势。 However, for datasets comprising longer sentences, such as CR (maximum sentence length is 105, whereas it ranges from 36-56 on the other sentiment datasets used here), the optimal region size may be larger. 同时，当增加不同卷积大小作为组合时，如果组合的卷积核大小接近于最佳大小（optimal region size），有助于结果的提升；相反，如果卷积核大小离最佳大小很远时，反而会产生负面影响。 建议首先试着找到最优的卷积核大小，然后在这个基础上添加和该卷积核大小类似的卷积核。 feature maps也就是输出通道（out channel），表明该卷积核大小的卷积核有多少个。 实验表明，最佳的feature maps和数据集相关，但一般不超过600。 it would seem that increasing the number of maps beyond 600 yields at best very marginal returns, and often hurts performance. 建议在600内搜索最优，如果在600的边缘还没有明显的效果下降，那么可以尝试大于600的feature maps。 激活函数实验结果： 结果表明，tanh、ReLU和不使用激活函数效果较好。tanh的优点是以0为中心，ReLU能够加速拟合，至于为什么不使用的效果会好，可能是因为模型较为简单： This indicates that on some datasets, a linear transformation is enough to capture thecorrelation between the word embedding and the output label. 建议使用tanh、ReLU或者干脆不使用。但如果模型更为复杂，有多层的结构，还是需要使用激活函数的。 pooling策略所有的实验都表明了，1-max pooling的效果比其他好，如k-max pooling。在pooling这一步可以直接选择1-max pooling。 This may be because the location of predictive contexts does not matter, and certain n-grams in the sentence can be more predictive on their own than the entire sentence considered jointly. 正则化主要是dropout和l2 norm constraint。dropout就是随机将一些神经元置为0，l2 norm constraint是对参数矩阵W进行整体缩放，使其不超过一定阈值。（与通常的l2 regularization不同，最早可追溯到Hinton的Improving neural networks by preventingco-adaptation of feature detectors） the l2 norm of a weight vector is linearly scaled to a constraint c when it exceeds this threshold, so a smaller c implies stronger regularization 实验表明，dropout起的作用很小，l2 norm没有提升甚至还会导致下降。可能是因为模型参数不多，因此过拟合的可能性较低。 建议设置较小的dropout和较大的l2 norm，当feature maps增大时，可以试着调节较大的dropout以避免过拟合。 建议及结论 刚开始的使用使用word2vec或者GloVe，如果数据量够大，可以尝试one-hot 线性搜索最佳的卷积核大小，如果句子够长，那么可以扩大搜索范围。一旦确定了最佳卷积核大小，尝试在该卷积核大小的附近进行组合，如最佳卷积核宽度是5，那么尝试[3,4,5]或者[2,3,4,5]等 使用较小的dropout和较大的max norm constraint，然后在[100,600]范围内搜索feature maps，如果最佳的feature maps在600附近，可以试着选择比600更大的范围 尝试不同的激活函数，通常tanh和ReLU是较好的，但也可以尝试什么都不加。 使用1-max pooling。 如果模型复杂，比如feature maps很大，那么可以尝试更为严格的正则化，如更大的dropout rate和较小的max norm constraint。 ReferenceConvolutional Neural Networks for Sentence Classification A Sensitivity Analysis of (and Practitioners’ Guide to) ConvolutionalNeural Networks for Sentence Classification]]></content>
      <tags>
        <tag>指南</tag>
        <tag>调参</tag>
        <tag>CNN</tag>
        <tag>情感分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Pytorch中的inplace的操作]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%85%B3%E4%BA%8EPytorch%E4%B8%ADin-place%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[最近在写Hierarchical attention network的时候遇到了如下的bug： one of the variables needed for gradient computation has been modified by an inplace operation 在查阅了文档和请教了其他人之后，最终找到了bug。 1234for i in range(seq_len): h_i = rnn_outputs[i] # batch,hidden*2 a_i = attn_weights[i].unsqueeze_(1) # take in-place opt may cause an error a_i = a_i.expand_as(h_i) # batch,hidden*2 这是我原来的逻辑，我在无意中做了inplace操作，导致了bug的发生。正确的做法应该是这样的： 12345for i in range(seq_len): h_i = rnn_outputs[i] # batch,hidden*2 # a_i = attn_weights[i].unsqueeze_(1) # take in-place opt may cause an error a_i = attn_weights[i].unsqueeze(1) # batch,1 a_i = a_i.expand_as(h_i) # batch,hidden*2 实际上，在实践过程中应当尽量避免inplace操作，在官方文档中也提到了（存疑）这点，虽然提供了inplace操作，但并不推荐使用。 具体的原因是，在Pytorch构建计算图的过程中，会记录每个节点是怎么来的，但inplace会破坏这种关系，使得在回传的时候没法正常求导。 特别地，有两种情况不应该使用inplace操作（摘自知乎）： 对于requires_grad=True的叶子张量(leaf tensor)不能使用inplace operation 对于在求梯度阶段需要用到的张量不能使用inplace operation Reference:https://zhuanlan.zhihu.com/p/38475183]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>遇到的问题</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[愿中国青年都摆脱冷气]]></title>
    <url>%2F2018%2F08%2F19%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%84%BF%E4%B8%AD%E5%9B%BD%E9%9D%92%E5%B9%B4%E9%83%BD%E6%91%86%E8%84%B1%E5%86%B7%E6%B0%94%2F</url>
    <content type="text"><![CDATA[近期的新闻常让人感到愤怒以致绝望… 愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光。就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。 —鲁迅《热风》]]></content>
      <tags>
        <tag>佳句分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段记录5]]></title>
    <url>%2F2018%2F08%2F19%2F%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%2F%E4%BB%A3%E7%A0%81%E5%88%86%E4%BA%AB5%2F</url>
    <content type="text"><![CDATA[1️⃣sklearn模型的保存与恢复123456789from sklearn import svmX = [[0, 0], [1, 1]]y = [0, 1]clf = svm.SVC()clf.fit(X, y) clf.fit(train_X,train_y)joblib.dump(clf, "train_model.m")clf = joblib.load("train_model.m")clf.predit(test_X) 2️⃣Dictionary类在构造字典时需要用到1234567891011121314151617181920212223242526class Dictionary(): def __init__(self): self.word2idx = &#123;&#125; self.idx2word = [] self.__vocab_size = 0 self.add_word('&lt;pad&gt;') self.add_word('&lt;UNK&gt;') def add_word(self, word): if word not in self.word2idx: self.idx2word.append(word) self.word2idx[word] = self.__vocab_size self.__vocab_size += 1 def __len__(self): return self.__vocab_size def get_index(self, word): if word in self.word2idx: return self.word2idx[word] else: return self.word2idx['&lt;UNK&gt;'] def get_word(self, idx): return self.idx2word[idx] 3️⃣对dict按元素排序的三种方法12345678910111213d=&#123;'apple':10,'orange':20,'banana':5,'watermelon':1&#125;#法1print(sorted(d.items(),key=lambda x:x[1])) #[('watermelon', 1), ('banana', 5), ('apple', 10), ('orange', 20)]#法2from operator import itemgetterprint(sorted(d.items(),key=itemgetter(1))) #[('watermelon', 1), ('banana', 5), ('apple', 10), ('orange', 20)]#法3print(sorted(d,key=d.get)) #['watermelon', 'banana', 'apple', 'orange'] 没有value了 4️⃣合并dict的三种方法1234567891011121314151617&gt;&gt;&gt; d1=&#123;'a':1&#125;&gt;&gt;&gt; d2=&#123;'b':2&#125;#法1&gt;&gt;&gt; d=&#123;**d1,**d2&#125;&gt;&gt;&gt; d&#123;'a': 1, 'b': 2&#125;#法2&gt;&gt;&gt; dd=dict(d1.items()|d2.items())&gt;&gt;&gt; dd&#123;'a': 1, 'b': 2&#125;#法3&gt;&gt;&gt; d1.update(d2)&gt;&gt;&gt; d1&#123;'a': 1, 'b': 2&#125; 5️⃣找到list最大最小值的index12345678lst = [40, 10, 20, 30]def minIndex(lst): return min(range(len(lst)),key=lst.__getitem__)def maxIndex(lst): return max(range(len(lst)),key=lst.__getitem__) print(minIndex(lst))print(maxIndex(lst))]]></content>
      <tags>
        <tag>code snippets</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Pytorch中的Embedding padding]]></title>
    <url>%2F2018%2F08%2F19%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%85%B3%E4%BA%8EPytorch%E4%B8%ADEmbedding%E7%9A%84padding%2F</url>
    <content type="text"><![CDATA[在Pytorch中，nn.Embedding()代表embedding矩阵，其中有一个参数padding_idx指定用以padding的索引位置。所谓padding，就是在将不等长的句子组成一个batch时，对那些空缺的位置补0，以形成一个统一的矩阵。 用法：1self.embedding = nn.Embedding(vocab_size, embed_dim,padding_idx=0) #也可以是别的数值 在显式设定padding_idx=0后，在自定义的词典内也应当在相应位置添加&lt;pad&gt;作为一个词。如： 1234567class Dictionary(): def __init__(self): self.word2idx = &#123;&#125; self.idx2word = [] self.__vocab_size = 0 self.add_word('&lt;pad&gt;') # should add &lt;pad&gt; first self.add_word('&lt;UNK&gt;') 那么对于padding_idx，内部是如何操作的呢？ 在查看了Embedding的源码后，发现设置了padding_idx，类内部会有如下操作： 12345678910#-----Embedding __init__ 内部--------------if _weight is None: self.weight = Parameter(torch.Tensor(num_embeddings, embedding_dim)) self.reset_parameters() #---------reset_parameters()--------def reset_parameters(self): self.weight.data.normal_(0, 1) if self.padding_idx is not None: self.weight.data[self.padding_idx].fill_(0) 也就是说，当Embedding是随机初始化的矩阵时，会对padding_idx所在的行进行填0。保证了padding行为的正确性。 那么，还需要保证一个问题，就是在反向回传的时候，padding_idx是不会更新的. 在查看了源码后发现在Embedding类内有如下注释： .. note:: With :attr:padding_idx set, the embedding vector at :attr:padding_idx is initialized to all zeros. However, note that this vector can be modified afterwards, e.g., using a customized initialization method, and thus changing the vector used to pad the output. The gradient for this vector from :class:~torch.nn.Embedding is always zero. 并且在查阅了其他资料后，发现该行确实会不更新。有意思的是，查阅源码并没有找到如何使其不更新的机制，因为在F.embedding函数中，返回： 1return torch.embedding(weight, input, padding_idx, scale_grad_by_freq, sparse) 但我并不能跳转到torch.embedding中，大概是因为这部分被隐藏了吧。我也没有再深究下去。我猜测有可能是在autograd内部有对该部分进行单独的处理，用mask屏蔽这部分的更新；或者一个更简单的方法，就是任其更新，但每一次都reset，将第一行手动设为全0。 附记： 假如说没有显式设置该行，是否padding就没有效果呢？我认为是的。 一般来说，我们都是以0作为padding的填充，如： 12 44 22 67 85 12 13 534 31 0 87 23 0 0 0 每一行代表一个句子，其中0作为填充。然后将该矩阵送入到embedding_lookup中，获得三维的tensor，那么0填充的部分，所获得的embedding表示应当是要全0。 假如不显式设置padding_idx=0，就可能会出现两个结果（个人推测)： ①本应该全0的地方，被词典中第一个词的词向量表示给替代了，因为将0作为索引去embedding矩阵获取到的词向量，就是第一个词的词向量，而该词并不全0。 ②词典的最后一个词被全0覆盖。F.embedding中有如下片段： 12345678if padding_idx is not None: if padding_idx &gt; 0: assert padding_idx &lt; weight.size(0), 'Padding_idx must be within num_embeddings' elif padding_idx &lt; 0: assert padding_idx &gt;= -weight.size(0), 'Padding_idx must be within num_embeddings' padding_idx = weight.size(0) + padding_idxelif padding_idx is None: padding_idx = -1 上面片段显示，padding_idx被设置为-1，也就是最后一个单词。做完这步紧接着就返回： 1return torch.embedding(weight, input, padding_idx, scale_grad_by_freq, sparse) 还是由于torch.embedding无法查看的原因，我不知道内部是如何实现的，但应该来说，最后一个词就是被覆盖了。]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Pytorch</tag>
        <tag>Embedding</tag>
        <tag>padding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Tricks[转]]]></title>
    <url>%2F2018%2F08%2F19%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2FPython%20Tricks%5B%E8%BD%AC%5D%2F</url>
    <content type="text"><![CDATA[原文地址:https://hackernoon.com/python-tricks-101-2836251922e0 我觉得这个介绍Python一些tricks的文章很好，能够更加熟悉Python的一些非常方便的用法。以下是我觉得有用的几个点。 1️⃣Reverse a String/List [::-1]解释：[:]表示取所有的元素，-1表示步进。[1:5:2]表示的就是从元素1到元素5，每2个距离取一个。 2️⃣transpose 2d array zip()相当于压缩，zip(*)相当于解压。 3️⃣Chained function call 非常简洁的写法。 4️⃣Copy List 之前谈过的Python的赋值、浅拷贝、深拷贝。 5️⃣Dictionary get 避免了dict不存在该元素的问题。 6️⃣✨Sort Dictionary by Value 其中第三种返回的是[‘watermelon’, ‘banana’, ‘apple’, ‘orange’]，没有value了。 7️⃣For…else 注意到如果for在中途break了，就不会进入到else了；只有顺利循环完才会进入到else。 1234567891011121314151617&gt;&gt;&gt; a=[1,2,0]&gt;&gt;&gt; for e in a:... if e==0:... break... else:... print('hello')... #什么都没有print&gt;&gt;&gt; for e in a:... print(e)... else:... print('hello')... 120hello 8️⃣Merge dict’s 合并dict的方法。 9️⃣Min and Max index in List]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Python</tag>
        <tag>Python tricks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识4]]></title>
    <url>%2F2018%2F08%2F19%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%864%2F</url>
    <content type="text"><![CDATA[1️⃣[概率校准(Probability Calibration)]一种对机器学习算法输出结果的校准，通过几个实验可以发现，概率校准能够一定程度提高表现。几个参考资料：直观理解: http://www.bubuko.com/infodetail-2133893.htmlSVC的概率校准在sklearn上的应用: https://blog.csdn.net/ericcchen/article/details/79337716✨完全手册: Calibration of Machine Learning Models 2️⃣[Paper]Hierarchical Attention Networks for Document Classification 亮点在使用层次的RNN结构，以及使用了attention方法。 参考了其他人的代码自己也试着实现了一个，GitHub地址：https://github.com/linzehui/pytorch-hierarchical-attention-network 3️⃣[XGBoost]kaggle神器XGBoost，一篇原理的详细介绍：http://www.cnblogs.com/willnote/p/6801496.html虽然还是有好些地方没搞懂，有必要从头学起。 4️⃣[Python]关于函数列表中单星号(*)和双星号(**)单星号： 代表接收任意多个非关键字参数，将其转换成元组： 1234def one(a,*b): """a是一个普通传入参数，*b是一个非关键字星号参数""" print(b)one(1,2,3,4,5,6) #输出：(2, 3, 4, 5, 6) 对一个普通变量使用单星号，表示对该变量拆分成单个元素 1234def fun(a,b): print(a,b)l=[1,2]fun(*l) #输出 1,2 双星号： 获得字典值 1234def two(a=1,**b): """a是一个普通关键字参数，**b是一个关键字双星号参数""" print(b)two(a=1,b=2,c=3,d=4,e=5,f=6) #输出&#123;'b': 2, 'c': 3, 'e': 5, 'f': 6, 'd': 4&#125; 5️⃣[Pytorch]在Pytorch中，只要一个tensor的requires_grad是true，那么两个tensor的加减乘除后的结果的requires_grad也会是true。]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Python</tag>
        <tag>Pytorch</tag>
        <tag>Paper</tag>
        <tag>概率校准</tag>
        <tag>Probability Calibration</tag>
        <tag>HAN</tag>
        <tag>XGBoost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词5]]></title>
    <url>%2F2018%2F08%2F19%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D5%2F</url>
    <content type="text"><![CDATA[本周太忙了，没背什么诗词，只背（复习）了部分的《滕王阁序》。 1️⃣ 滕王阁序嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空馀报国之情；阮籍猖狂，岂效穷途之哭！ 勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗慤之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；锺期既遇，奏流水以何惭？ 注释：冯唐：西汉人，有才能却一直不受重用。汉武帝时选求贤良，有人举荐冯唐，可是他已九十多岁，难再做官了。李广：汉武帝时的名将，多年抗击匈奴，军功很大，却终身没有封侯。 贾谊：汉文帝本想任贾谊为公卿，但因朝中权贵反对，就疏远了贾谊，任他为长沙王太傅。梁鸿：东汉人，因作诗讽刺君王，得罪了汉章帝，被迫逃到齐鲁一带躲避。 酌（zhuó）贪泉而觉爽：喝下贪泉的水，仍觉得心境清爽。古代传说广州有水名贪泉，人喝了这里的水就会变得贪婪。这句是说有德行的人在污浊的环境中也能保持纯正，不被污染。处涸辙以犹欢：处在奄奄待毙的时候，仍然乐观开朗。处河辙：原指鲋鱼处在干涸的车辙旦。比喻人陷入危急之中。 孟尝：东汉人，为官清正贤能，但不被重用，后来归田。阮籍：三国魏诗人，他有时独自驾车出行，到无路处便恸哭而返，借此宣泄不满于现实的苦闷心情。 终军：《汉书·终军传》记载，汉武帝想让南越（今广东、广西一带）王归顺，派终军前往劝说，终军请求给他长缨，必缚住南越王，带回到皇宫门前（意思是一定完成使命）。后来用“请缨”指投军报国。 宗悫（què）：南朝宋人，少年时很有抱负，说“愿乘长风破万里浪”。 簪（zān）笏（hù）：这里代指官职。晨昏：晨昏定省，出自 《礼记·曲礼上》，释义为旧时侍奉父母的日常礼节。 非谢家之宝树，接孟氏之芳邻：自己并不是像谢玄那样出色的人才，却能在今日的宴会上结识各位名士。谢家之宝树：指谢玄。《晋书·谢玄传》记载，晋朝谢安曾问子侄们：为什么人们总希望自己的子弟好？侄子谢玄回答：“譬如芝兰玉树，欲使其生于庭阶耳。”后来就称谢玄为谢家宝树。孟氏之芳邻：这里借孟子的母亲为寻找邻居而三次搬家的故事，来指赴宴的嘉宾。 他日趋庭，叨陪鲤对：过些时候自己将到父亲那里陪侍和聆听教诲。趋庭：快步走过庭院，这是表示对长辈的恭敬。叨：惭愧地承受，表示自谦。鲤对：孔鲤是孔子的儿子，鲤对指接受父亲教诲。事见《论语·季氏》：（孔子）尝独立，（孔）鲤趋而过庭。（子）曰：“学诗乎？”对曰：“未也。”“不学诗，无以言。”鲤退而学诗。他日，又独立，鲤趋而过庭。（子）曰：“学礼乎？”对曰：‘未也。”“不学礼，无以立。”鲤退而学礼。 捧袂（mèi）：举起双袖作揖，指谒见阎公。喜托龙门：（受到阎公的接待）十分高兴，好像登上龙门一样。 杨意：即蜀人杨得意，任掌管天子猎犬的官，西汉辞赋家司马相如是由他推荐给汉武帝的。凌云：这里指司马相如的赋，《史记·司马相如传》说，相如献《大人赋》，“天子大悦，飘飘有凌云之气，似游天地之间”。钟期：即钟子期。]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的拷贝]]></title>
    <url>%2F2018%2F08%2F18%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2FPython%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[Python的拷贝和C/C++的差别很大，很经常就容易搞混，因此记录一下。 赋值、拷贝 赋值：实际上就是对象的引用，没有开辟新的内存空间12lst=[1,2,3]l=lst 浅拷贝:创建了新对象，但是内容是对原对象的引用，有三种形式 切片 12l=lst[:]l=[i for i in lst] 工厂 1l=list(lst) copy 12import copyl=copy.copy(lst) 深拷贝:copy中的deepcopy，生成一个全新的对象，与原来的对象无关 12import copyl=copy.deepcopy(lst) 例子12345678910111213141516171819202122232425262728293031### 引用https://www.cnblogs.com/huangbiquan/p/7795152.html 的例子###&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,3,4,['a','b']] #定义一个列表a&gt;&gt;&gt; b = a #赋值&gt;&gt;&gt; c = copy.copy(a) #浅拷贝&gt;&gt;&gt; d = copy.deepcopy(a) #深拷贝&gt;&gt;&gt; a.append(5)&gt;&gt;&gt; print(a)[1, 2, 3, 4, ['a', 'b'], 5] #a添加一个元素5&gt;&gt;&gt; print(b) [1, 2, 3, 4, ['a', 'b'], 5] #b跟着添加一个元素5 &gt;&gt;&gt; print(c)[1, 2, 3, 4, ['a', 'b']] #c保持不变&gt;&gt;&gt; print(d)[1, 2, 3, 4, ['a', 'b']] #d保持不变&gt;&gt;&gt; a[4].append('c') &gt;&gt;&gt; print(a)[1, 2, 3, 4, ['a', 'b', 'c'], 5] #a中的list(即a[4])添加一个元素c&gt;&gt;&gt; print(b)[1, 2, 3, 4, ['a', 'b', 'c'], 5] #b跟着添加一个元素c&gt;&gt;&gt; print(c)[1, 2, 3, 4, ['a', 'b', 'c']] #c跟着添加一个元素c&gt;&gt;&gt; print(d)[1, 2, 3, 4, ['a', 'b']] #d保持不变#说明如下：#1.外层添加元素时， 浅拷贝c不会随原列表a变化而变化；内层list添加元素时，浅拷贝c才会变化。#2.无论原列表a如何变化，深拷贝d都保持不变。#3.赋值对象随着原列表一起变化 Referencehttps://www.cnblogs.com/huangbiquan/p/7795152.htmlhttps://www.cnblogs.com/xueli/p/4952063.html]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Python</tag>
        <tag>拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将ELMo词向量用于中文]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%A6%82%E4%BD%95%E5%B0%86ELMo%E8%AF%8D%E5%90%91%E9%87%8F%E7%94%A8%E4%BA%8E%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[10.10更新：ELMo已经由哈工大组用PyTorch重写了，并且提供了中文的预训练好的language model，可以直接使用，但代码中似乎还不能对生成的词向量进行加权求和，这部分可能需要自己改。如果可能我应该会再写一篇如何改代码的博客。 ELMo于今年二月由AllenNLP提出，与word2vec或GloVe不同的是其动态词向量的思想，其本质即通过训练language model，对于一句话进入到language model获得不同的词向量。根据实验可得，使用了Elmo词向量之后，许多NLP任务都有了大幅的提高。 论文:Deep contextualized word representations AllenNLP一共release了两份ELMo的代码，一份是Pytorch版本的，另一份是Tensorflow版本的。Pytorch版本的只开放了使用预训练好的词向量的接口，但没有给出自己训练的接口，因此无法使用到中文语料中。Tensorflow版本有提供训练的代码，因此本文记录如何将ELMo用于中文语料中，但本文只记录使用到的部分，而不会分析全部的代码。 需求:使用预训练好的词向量作为句子表示直接传入到RNN中(也就是不使用代码中默认的先过CNN)，在训练完后，将模型保存，在需要用的时候load进来，对于一个特定的句子，首先将其转换成预训练的词向量，传入language model之后最终得到ELMo词向量。 准备工作: 将中文语料分词 训练好GloVe词向量或者word2vec 下载bilm-tf代码 生成词表 vocab_file （训练的时候要用到） optional:阅读Readme optional:通读bilm-tf的代码，对代码结构有一定的认识 思路: 将预训练的词向量读入 修改bilm-tf代码 option部分 添加给embedding weight赋初值 添加保存embedding weight的代码 开始训练，获得checkpoint和option文件 运行脚本，获得language model的weight文件 将embedding weight保存为hdf5文件形式 运行脚本，将语料转化成ELMo embedding。 训练GloVe或word2vec可参见我以前的博客或者网上的教程。注意到，如果要用gensim导入GloVe训好的词向量，需要在开头添加num_word embedding_dim。 如： 获得vocab词表文件注意到，词表文件的开头必须要有&lt;S&gt; &lt;/S&gt; &lt;UNK&gt;，且大小写敏感。并且应当按照单词的词频降序排列。可以通过手动添加这三个特殊符号。如： 代码：1234567891011121314model=gensim.models.KeyedVectors.load_word2vec_format( fname='/home/zhlin/GloVe/vectors.txt',binary=False)words=model.vocabwith open('vocab.txt','w') as f: f.write('&lt;S&gt;') f.write('\n'） f.write('&lt;/S&gt;') f.write('\n') f.write('&lt;UNK&gt;') f.write('\n') # bilm-tf 要求vocab有这三个符号，并且在最前面 for word in words: f.write(word) f.write('\n') 修改bilm-tf代码注意到，在使用该代码之前，需要安装好相应的环境。 如果使用的是conda作为默认的Python解释器，强烈建议使用conda安装，否则可能会出现一些莫名的错误。123conda install tensorflow-gpu=1.4conda install h5pypython setup.py install #应在bilm-tf的文件夹下执行该指令 然后再运行测试代码，通过说明安装成功。 修改train_elmo.pybin文件夹下的train_elmo.py是程序的入口。主要修改的地方： load_vocab的第二个参数应该改为None n_gpus CUDA_VISIBLE_DEVICES 根据自己需求改 n_train_tokens 可改可不改，影响的是输出信息。要查看自己语料的行数，可以通过wc -l corpus.txt 查看。 option的修改，将char_cnn部分都注释掉，其他根据自己需求修改 如： 修改LanguageModel类由于我需要传入预训练好的GloVe embedding，那么还需要修改embedding部分，这部分在bilm文件夹下的training.py，进入到LanguageModel类中_build_word_embeddings函数中。注意到，由于前三个是&lt;S&gt; &lt;/S&gt; &lt;UNK&gt;，而这三个字符在GloVe里面是没有的，因此这三个字符的embedding应当在训练的时候逐渐学习到，而正因此 embedding_weights的trainable应当设为True 如: 修改train函数添加代码，使得在train函数的最后保存embedding文件。 训练并获得weights文件训练需要语料文件corpus.txt，词表文件vocab.txt。 训练cd到bilm-tf文件夹下，运行12345export CUDA_VISIBLE_DEVICES=4nohup python -u bin/train_elmo.py \--train_prefix='/home/zhlin/bilm-tf/corpus.txt' \--vocab_file /home/zhlin/bilm-tf/glove_embedding_vocab8.10/vocab.txt \--save_dir /home/zhlin/bilm-tf/try &gt;bilm_out.txt 2&gt;&amp;1 &amp; 根据实际情况设定不同的值和路径。 运行情况： PS:运行过程中可能会有warning: ‘list’ object has no attribute ‘name’WARNING:tensorflow:Error encountered when serializing lstm_output_embeddings.Type is unsupported, or the types of the items don’t match field type in CollectionDef. 应该不用担心，还是能够继续运行的，后面也不受影响。 在等待了相当长的时间后，在save_dir文件夹内生成了几个文件，其中checkpoint和options是关键，checkpoint能够进一步生成language model的weights文件，而options记录language model的参数。 获得language model的weights接下来运行bin/dump_weights.py将checkpoint转换成hdf5文件。 123nohup python -u /home/zhlin/bilm-tf/bin/dump_weights.py \--save_dir /home/zhlin/bilm-tf/try \--outfile /home/zhlin/bilm-tf/try/weights.hdf5 &gt;outfile.txt 2&gt;&amp;1 &amp; 其中save_dir是checkpoint和option文件保存的地址。 接下来等待程序运行： 最终获得了想要的weights和option： 将语料转化成ELMo embedding由于我们有了vocab_file、与vocab_file一一对应的embedding h5py文件、以及language model的weights.hdf5和options.json。接下来参考usage_token.py将一句话转化成ELMo embedding。 参考代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import tensorflow as tfimport osfrom bilm import TokenBatcher, BidirectionalLanguageModel, weight_layers, \ dump_token_embeddings# Our small dataset.raw_context = [ '这 是 测试 .', '好的 .']tokenized_context = [sentence.split() for sentence in raw_context]tokenized_question = [ ['这', '是', '什么'],]vocab_file='/home/zhlin/bilm-tf/glove_embedding_vocab8.10/vocab.txt'options_file='/home/zhlin/bilm-tf/try/options.json'weight_file='/home/zhlin/bilm-tf/try/weights.hdf5'token_embedding_file='/home/zhlin/bilm-tf/glove_embedding_vocab8.10/vocab_embedding.hdf5'## Now we can do inference.# Create a TokenBatcher to map text to token ids.batcher = TokenBatcher(vocab_file)# Input placeholders to the biLM.context_token_ids = tf.placeholder('int32', shape=(None, None))question_token_ids = tf.placeholder('int32', shape=(None, None))# Build the biLM graph.bilm = BidirectionalLanguageModel( options_file, weight_file, use_character_inputs=False, embedding_weight_file=token_embedding_file)# Get ops to compute the LM embeddings.context_embeddings_op = bilm(context_token_ids)question_embeddings_op = bilm(question_token_ids)elmo_context_input = weight_layers('input', context_embeddings_op, l2_coef=0.0)with tf.variable_scope('', reuse=True): # the reuse=True scope reuses weights from the context for the question elmo_question_input = weight_layers( 'input', question_embeddings_op, l2_coef=0.0 )elmo_context_output = weight_layers( 'output', context_embeddings_op, l2_coef=0.0)with tf.variable_scope('', reuse=True): # the reuse=True scope reuses weights from the context for the question elmo_question_output = weight_layers( 'output', question_embeddings_op, l2_coef=0.0 )with tf.Session() as sess: # It is necessary to initialize variables once before running inference. sess.run(tf.global_variables_initializer()) # Create batches of data. context_ids = batcher.batch_sentences(tokenized_context) question_ids = batcher.batch_sentences(tokenized_question) # Compute ELMo representations (here for the input only, for simplicity). elmo_context_input_, elmo_question_input_ = sess.run( [elmo_context_input['weighted_op'], elmo_question_input['weighted_op']], feed_dict=&#123;context_token_ids: context_ids, question_token_ids: question_ids&#125; )print(elmo_context_input_,elmo_context_input_) 可以修改代码以适应自己的需求。 Referencehttps://github.com/allenai/bilm-tf]]></content>
      <tags>
        <tag>ELMo</tag>
        <tag>教程</tag>
        <tag>词向量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段记录4]]></title>
    <url>%2F2018%2F08%2F12%2F%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%2F%E4%BB%A3%E7%A0%81%E5%88%86%E4%BA%AB4%2F</url>
    <content type="text"><![CDATA[本周没有什么代码要记录的。 1️⃣sklearn之Pipeline例子用机器学习解决问题的流程：(去掉部分数据）—&gt; 获取feature（Tf-idf等） —&gt; （feature selection，chi2、互信息等） —&gt; （缩放/正则化） —&gt; 分类器 —&gt; GridSearch/RandomizedSearch调参 123456789101112131415161718192021222324252627282930pipe=Pipeline([ #建立pipeline ('vect',TfidfVectorizer()), ('select',SelectKBest(chi2), ('norm',MaxAbsScaler()), ('svm',svm.LinearSVC())])parameters=&#123; 'vect__ngram_range':[(1,1),(1,2),(1,3),(2,3)], 'vect__max_df':[0.6,0.7,0.8,0.9], 'vect__min_df':[1,3,5,7,9], 'vect__norm':['l1','l2'], 'svm__penalty':['l1','l2'], 'svm__loss':['squared_hinge'], 'svm__dual':[False,True], 'svm__tol':[1e-5,1e-4], 'svm__C':[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1], 'svm__class_weight':[None,'balanced'], 'svm__max_iter':[1000,5000]&#125;grid_search_model=GridSearchCV(pipe,parameters,error_score=0,n_jobs=5)grid_search_model.fit(train[column],train['class'])for para_name in sorted(parameters.keys()): print(para_name,grid_search_model.best_params_[para_name])print("cv_result:")print(grid_search_model.cv_results_)]]></content>
      <tags>
        <tag>code snippets</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识3]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%863%2F</url>
    <content type="text"><![CDATA[1️⃣[Python]在服务器上跑代码时，如 python project/folder1/a.py，如果a.py引用了一个自定义的模块但又不在folder1内，此时interpreter就会报错，提示找不到该模块。这是因为解释器默认只会在同一个folder下查找。解决方案是在运行前显式添加查找范围。如：1export PYTHONPATH=/home/zhlin/bilm-tf:$PYTHONPATH 那么python解释器就会到该目录下去找。 2️⃣[度量标准] 准确率(accuracy): $ACC=\frac{TP+TN}{TP+TN+FP+FN}$ 衡量的是分类器预测准确的比例 召回率(recall): $Recall=\frac{TP}{TP+FN}$ 正例中被分对的比例，衡量了分类器对正例的识别能力。 精确率(Precision): $P=\frac{TP}{TP+FP}$度量了被分为正例的示例中实际为正例的比例。 F-Measure: $F=\frac{(\alpha^2 +1)P*R}{\alpha^2 (P+R)}$ 其中P是Precision,R是Recall。综合考量了两种度量。 当$\alpha=1$时，称为F1值 $F1=\frac{2PR}{P+R}$ 3️⃣[调参技巧]在google发布的一份关于text-classification的guide中，提到了几个调参的trick。 在feature selection步骤中，卡方检验chi2和方差分析的F值 f_classif的表现相当，在大约选择20k的feature时，准确率达到顶峰，当feature越多，效果并没有提升甚至会下降。 在文本分类中，似乎使用normalization并没有多少用处，建议跳过。 Normalization converts all feature/sample values to small and similar values. This simplifies gradient descent convergence in learning algorithms. From what we have seen, normalization during data preprocessing does not seem to add much value in text classification problems; we recommend skipping this step. 实际上我也测试过，发现确实normalization对于准确率的提高没什么帮助，甚至还有一点下降。]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Python</tag>
        <tag>度量标准</tag>
        <tag>调参技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词4]]></title>
    <url>%2F2018%2F08%2F12%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D4%2F</url>
    <content type="text"><![CDATA[1️⃣ 灞上秋居[唐] 马戴灞原风雨定，晚见雁行频。落叶他乡树，寒灯独夜人。空园白露滴，孤壁野僧邻。寄卧郊扉久，何年致此身。 http://m.xichuangzhu.com/work/57b8a4080a2b58005c9108d9 2️⃣ 唐多令[宋] 刘过芦叶满汀洲，寒沙带浅流。二十年重过南楼。柳下系船犹未稳，能几日，又中秋。黄鹤断矶头，故人今在否？旧江山浑是新愁。欲买桂花同载酒，终不似、少年游。 http://m.xichuangzhu.com/work/57b922e7c4c9710055904842]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim常用快捷键]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2FVim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[在服务器经常要用到Vim，因此记录常用的快捷键并熟悉之。 退出:q 退出:wq 写入并退出:q! 退出并忽略所有更改:e! 放弃修改并打开原来的文件 插入i 在当前位置前插入a 在当前位置后插入 撤销:u 撤销:U 撤销整行操作Ctrl+r 重做 删除:md 删除第m行nd 删除当前行开始的n行(一共n+1行)dd 删除当前行D 删除当前字符至行尾:m,nd 删除从m到n行的内容，如: :100,10000d:m,$d 删除m行及以后所有的行:10d 移动:n 跳转到行号 如， :100gg 跳到行首G(shift+g)移动到文件尾 搜索/text 搜索text，n搜索下一个，N搜索上一个?text 反向查找:set ignorecase 忽略大小写查找:set noignorecase 不忽略大小写查找*或# 对光标处的单词搜索 复制粘贴v 从当前位置开始，光标经过的地方被选中，再按一下v结束 环境设置:set nu 显示行号:set nonu 隐藏行号:set hlsearch 设置搜索结果高亮 Referencehttps://www.cnblogs.com/wangrx/p/5907013.htmlhttps://www.cnblogs.com/yangjig/p/6014198.html]]></content>
      <tags>
        <tag>Vim</tag>
        <tag>杂七杂八</tag>
        <tag>快捷键</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pycharm常用技巧]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2FPycharm%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[记录Pycharm的一些技巧，让Pycharm更顺手 快捷键0️⃣Double Shift 万能搜索可以搜索文件名、类名、方法名、目录名（在关键字前面加/ ），并不能用来搜索任意关键字 1️⃣ Command+F 在页面搜索 2️⃣ Ctrl+Shift+F Find in Path 在路径下搜索 3️⃣✨Command+E 快速查找文件显示最近打开的文件 4️⃣ Shift+Enter 任意位置换行无论光标在何处都可以直接另起一行 5️⃣ Option+Enter 自动导入模块；万能提示键自动导入如何设置见小技巧#0️⃣ 6️⃣ Ctrl+F10 运行我已经添加了Ctrl+R作为另一对运行快捷键 7️⃣ Command+Shift+ +/- 展开/收缩代码 8️⃣ Option+F 在Dash中搜索 小技巧0️⃣ Pycharm自动导入模块https://blog.csdn.net/lantian_123/article/details/78094148 1️⃣ ✨远程部署工程 强烈推荐两步走：配置服务器映射+配置服务器解释器 2️⃣跳转后如何回退开启toolbar即可https://segmentfault.com/a/1190000010205945 Referencehttps://foofish.net/pycharm-tips.htmlhttps://blog.csdn.net/lantian_123/article/details/78094148https://segmentfault.com/a/1190000010205945]]></content>
      <tags>
        <tag>杂七杂八</tag>
        <tag>快捷键</tag>
        <tag>技巧</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题]]></title>
    <url>%2F2018%2F08%2F06%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%97%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[人这辈子一共会死三次。 第一次是你的心脏停止跳动，那么从生物的角度来说，你死了； 第二次是在葬礼上，认识你的人都来祭奠，那么你在社会关系上的事实存在就死了； 第三次是在最后一个记得你的人死后，那你就真的死了。]]></content>
      <tags>
        <tag>佳句分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人可以卑微如尘土,不可扭曲如蛆虫]]></title>
    <url>%2F2018%2F08%2F05%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E4%BA%BA%E5%8F%AF%E4%BB%A5%E5%8D%91%E5%BE%AE%E5%A6%82%E5%B0%98%E5%9C%9F%2C%E4%B8%8D%E5%8F%AF%E6%89%AD%E6%9B%B2%E5%A6%82%E8%9B%86%E8%99%AB%2F</url>
    <content type="text"><![CDATA[如果天总也不亮，那就摸黑过生活; 如果发出声音是危险的，那就保持沉默; 如果自觉无力发光，那就别去照亮别人。 但是——不要习惯了黑暗就为黑暗辩护; 不要为自己的苟且而得意洋洋; 不要嘲讽那些比自己更勇敢、更有热量的人们。 可以卑微如尘土，不可扭曲如蛆虫。]]></content>
      <tags>
        <tag>佳句分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python惯例[转]]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2FPython%E6%83%AF%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[fork from https://github.com/jackfrued/Python-100-Days/blob/master/Python惯例.md Python惯例“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。 让代码既可以被导入又可以被执行。 1if __name__ == '__main__': 用下面的方式判断逻辑“真”或“假”。 12if x:if not x: 好的代码： 12345name = 'jackfrued'fruits = ['apple', 'orange', 'grape']owners = &#123;'1001': '骆昊', '1002': '王大锤'&#125;if name and fruits and owners: print('I love fruits!') 不好的代码： 12345name = 'jackfrued'fruits = ['apple', 'orange', 'grape']owners = &#123;'1001': '骆昊', '1002': '王大锤'&#125;if name != '' and len(fruits) &gt; 0 and owners != &#123;&#125;: print('I love fruits!') 善于使用in运算符。 12if x in items: # 包含for x in items: # 迭代 好的代码： 123name = 'Hao LUO'if 'L' in name: print('The name has an L in it.') 不好的代码： 123name = 'Hao LUO'if name.find('L') != -1: print('This name has an L in it!') 不使用临时变量交换两个值。 1a, b = b, a 用序列构建字符串。 好的代码： 123chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']name = ''.join(chars)print(name) # jackfrued 不好的代码： 12345chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']name = ''for char in chars: name += charprint(name) # jackfrued EAFP优于LBYL。 EAFP - Easier to Ask Forgiveness than Permission. LBYL - Look Before You Leap. 好的代码： 123456d = &#123;'x': '5'&#125;try: value = int(d['x']) print(value)except (KeyError, TypeError, ValueError): value = None 不好的代码： 1234567d = &#123;'x': '5'&#125;if 'x' in d and isinstance(d['x'], str) \ and d['x'].isdigit(): value = int(d['x']) print(value)else: value = None 使用enumerate进行迭代。 好的代码： 123fruits = ['orange', 'grape', 'pitaya', 'blueberry']for index, fruit in enumerate(fruits): print(index, ':', fruit) 不好的代码： 12345fruits = ['orange', 'grape', 'pitaya', 'blueberry']index = 0for fruit in fruits: print(index, ':', fruit) index += 1 用生成式生成列表。 好的代码： 123data = [7, 20, 3, 15, 11]result = [num * 3 for num in data if num &gt; 10]print(result) # [60, 45, 33] 不好的代码： 123456data = [7, 20, 3, 15, 11]result = []for i in data: if i &gt; 10: result.append(i * 3)print(result) # [60, 45, 33] 用zip组合键和值来创建字典。 好的代码： 1234keys = ['1001', '1002', '1003']values = ['骆昊', '王大锤', '白元芳']d = dict(zip(keys, values))print(d) 不好的代码： 123456keys = ['1001', '1002', '1003']values = ['骆昊', '王大锤', '白元芳']d = &#123;&#125;for i, key in enumerate(keys): d[key] = values[i]print(d) 说明：这篇文章的内容来自于网络，有兴趣的读者可以阅读原文。 注：许多原则我认为非常有意义，能够摆脱C/C++的风格，真正写出Pythonic的代码。让我有很大感触的是1、3、8，能够写出非常简洁优雅的代码。同时6我之前从没注意过，习惯了C/C++风格之后总是会在执行之前考虑所有情况，但确实不够优雅，今后可以尝试EAFP风格（什么是EAFP）。]]></content>
      <tags>
        <tag>杂七杂八</tag>
        <tag>碎片知识</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何训练GloVe中文词向量]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83GloVe%E4%B8%AD%E6%96%87%E8%AF%8D%E5%90%91%E9%87%8F%2F</url>
    <content type="text"><![CDATA[准备语料准备好自己的语料，保存为txt，每行一个句子或一段话，注意要分好词。 准备源码从GitHub下载代码，https://github.com/stanfordnlp/GloVe将语料corpus.txt放入到Glove的主文件夹下。 修改bash打开demo.sh，修改相应的内容 因为demo默认是下载网上的语料来训练的，因此如果要训练自己的语料，需要注释掉 修改参数设置，将CORPUS设置成语料的名字 执行bash文件进入到主文件夹下 make bash demo.sh 注意，如果训练数据较大，则训练时间较长，那么建议使用nohup来运行程序 1nohup bash demo.sh &gt;output.txt 2&gt;&amp;1 &amp; 坐等训练，最后会得到vectors.txt 以及其他的相应的文件。如果要用gensim的word2ve load进来，那么需要在vectors.txt的第一行加上vacob_size vector_size，第一个数指明一共有多少个向量，第二个数指明每个向量有多少维。 参考https://www.cnblogs.com/echo-cheng/p/8561171.html]]></content>
      <tags>
        <tag>教程</tag>
        <tag>GloVe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识2]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%862%2F</url>
    <content type="text"><![CDATA[1️⃣[Pytorch]避免写出： 1x = Variable(torch.zeros(...), requires_grad=True).cuda() 而是应该要： 1x = Variable(torch.zeros(...).cuda(), requires_grad=True) Reference:https://discuss.pytorch.org/t/variable-grad-is-always-none-when-extending-autograd/12187 2️⃣[Tf-idf]本周因为比赛的原因了解了一下各种文本建模的方法。Tf-idf能够取得不错的成绩，但有一定的缺陷。 TF-IDF用于向量空间模型，进行文档相似度计算是相当有效的。但在文本分类中单纯使用TF-IDF来判断一个特征是否有区分度是不够的。 它仅仅综合考虑了该词在文档中的重要程度和文档区分度。 它没有考虑特征词在类间的分布。特征选择所选择的特征应该在某类出现多，而其它类出现少，即考察各类的文档频率的差异。如果一个特征词，在各个类间分布比较均匀，这样的词对分类基本没有贡献；但是如果一个特征词比较集中的分布在某个类中，而在其它类中几乎不出现，这样的词却能够很好代表这个类的特征，而TF-IDF不能区分这两种情况。 它没有考虑特征词在类内部文档中的分布情况。在类内部的文档中，如果特征词均匀分布在其中，则这个特征词能够很好的代表这个类的特征，如果只在几篇文档中出现，而在此类的其它文档中不出现，显然这样的特征词不能够代表这个类的特征。 Reference:https://blog.csdn.net/mmc2015/article/details/46771791 3️⃣[卡方检验CHI]在文本分类中，用于选择最相关的特征。 Reference:https://blog.csdn.net/blockheadls/article/details/49977361 4️⃣[文本分类]各种文本分类方法的简单介绍。 Reference:https://github.com/wangjiang0624/Note/blob/master/MachineLearning/文本分类.md 5️⃣[Python]collections的两个有用的类 named_tuple：快速建立一个类，使得可以使用属性来访问而非索引，提高了代码可读性 12345from collections import namedtuplePoint = namedtuple('Point',['x','y'])p = Point(1,2)print(p.x) # 1print(p.y) # 2 Counter：统计字符出现的次数 1234567from collections import Countercount = Counter([...]).most_commom() #会按照出现的次数排序，通常可用于构建词典for c in count: # c是一个tuple，c[0]是词，c[1]是频率 if c[1]&gt;= threshold: vocab.add_word(c[0]) else: break Counter用法：https://blog.csdn.net/u014755493/article/details/69812244 6️⃣[nohup]本周在服务器上跑代码的时候遇到一个问题，使用nohup执行python程序时，发现输出文件没有显示。以为是代码的问题，但经过排查并非是代码的问题。通过查阅资料，发现问题所在：因为python输出有缓冲，导致output不能马上看到输出。实际上，在等待了一段时间后，输出文件终于显示出来了。 解决方案：使用python的参数 -u 使得python不启用缓冲。 1nohup python -u test.py &gt; nohup.out 2&gt;&amp;1 &amp; Reference:https://blog.csdn.net/sunlylorn/article/details/19127107 7️⃣[hexo配置] mathjax配置: https://www.jianshu.com/p/7ab21c7f0674 配置域名:https://www.zhihu.com/question/31377141 配置sitemap:http://www.yuan-ji.me/Hexo-优化：提交sitemap及解决百度爬虫抓取-GitHub-Pages-问题/ 8️⃣[Paper]Learning Chinese Word Representations From Glyphs Of Characters 使用图像的卷积来生成词向量:]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Pytorch</tag>
        <tag>Paper</tag>
        <tag>Tf-idf</tag>
        <tag>文本分类</tag>
        <tag>hexo</tag>
        <tag>nohup</tag>
        <tag>CHI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段记录3]]></title>
    <url>%2F2018%2F08%2F05%2F%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%2F%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%88%86%E4%BA%AB3%2F</url>
    <content type="text"><![CDATA[本周只有简单的代码。 1️⃣使用gensim训练word2vec12345678910111213141516#encoding=utf-8from gensim.models import word2vecsentences=word2vec.Text8Corpus(u'分词后的爽肤水评论.txt') #sentence:[ [ a b ],[c d]... ]model=word2vec.Word2Vec(sentences, size=50) #size:dim y2=model.similarity(u"好", u"还行") #计算相似度print(y2)for i in model.most_similar(u"滋润"): print i[0],i[1] #保存model.save('/model/word2vec_model')new_model=gensim.models.Word2Vec.load('/model/word2vec_model') 2️⃣使用Counter建立词表123456789def build_dict(dataset,min_freq=5): dictionary=Dictionary() count=Counter(flat(dataset)).most_common() for c in count: if c[1]&gt;=min_freq: dictionary.add_word(c[0]) else: break return dictionary]]></content>
      <tags>
        <tag>code snippets</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词3]]></title>
    <url>%2F2018%2F08%2F05%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D3%2F</url>
    <content type="text"><![CDATA[本周背的都是比较简单的。 1️⃣ 把酒问月[唐] 李白青天有月来几时？我今停杯一问之。人攀明月不可得，月行却与人相随。皎如飞镜临丹阙，绿烟灭尽清辉发。但见宵从海上来，宁知晓向云间没。白兔捣药秋复春，嫦娥孤栖与谁邻？今人不见古时月，今月曾经照古人。古人今人若流水，共看明月皆如此。唯愿当歌对酒时，月光长照金樽里。 http://m.xichuangzhu.com/work/57b8f6f4165abd0054bf8c13 2️⃣ 金缕衣[唐] 杜秋娘劝君莫惜金缕衣，劝君惜取少年时。花开堪折直须折，莫待无花空折枝。 http://m.xichuangzhu.com/work/57b92bdca633bd00665eb99e 3️⃣ 北青萝[唐] 李商隐残阳西入崦，茅屋访孤僧。落叶人何在，寒云路几层。独敲初夜磬，闲倚一枝藤。世界微尘里，吾宁爱与憎。 崦（yān）：即“崦嵫（zī）”，山名，在甘肃。古时常用来指太阳落山的地方。磬（qìng）：古代打击乐器，形状像曲尺，用玉、石制成，可悬挂。 http://m.xichuangzhu.com/work/57b8ee240a2b58005c91c99e 4️⃣ 夏日绝句[宋] 李清照生当作人杰，死亦为鬼雄。至今思项羽，不肯过江东。 http://m.xichuangzhu.com/work/57b911dac4c97100558fb30e 5️⃣ 雨霖铃[宋] 柳永寒蝉凄切，对长亭晚，骤雨初歇。都门帐饮无绪，留恋处，兰舟催发。执手相看泪眼，竟无语凝噎。念去去，千里烟波，暮霭沉沉楚天阔。多情自古伤离别，更那堪、冷落清秋节。今宵酒醒何处？杨柳岸，晓风残月。此去经年，应是良辰好景虚设。便纵有千种风情，更与何人说？ http://m.xichuangzhu.com/work/57ad742f5bbb500062bc7c9c]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Pytorch中grad的理解]]></title>
    <url>%2F2018%2F08%2F03%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%85%B3%E4%BA%8EPytorch%E4%B8%ADgrad%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[事情起源于我写了一个CNN用于文本分类，但loss一直没降，因此我尝试print(loss.grad)的grad，发现神奇的是loss grad显示为None，接着尝试print(y_pred.grad)，同样是None，但再print loss和y_pred的requires_grad发现是正常的True。 在查阅了资料，以及问了学长之后发现原来并不是bug，而是因为，Pytorch默认不会保存中间节点(intermediate variable)的grad，此举是为了节省内存。 By default, gradients are only retained for leaf variables. non-leaf variables’ gradients are not retained to be inspected later. This was done by design, to save memory. https://discuss.pytorch.org/t/why-cant-i-see-grad-of-an-intermediate-variable/94 实际上可以通过retain_grad()或者hook来查看中间节点的grad。 我后面尝试print了叶子节点，如 print(CNN_model.fc.weight.grad)，最终获得了正确的grad。 ps：所谓中间节点，是由其他节点计算所得的tensor，而叶子节点则是自己定义出来的。 最后我发现，原来loss一直没降的原因是因为我定义的CNN过于复杂，并且数据集偏小，无法快速收敛导致的。]]></content>
      <tags>
        <tag>遇到的问题</tag>
        <tag>Pytorch</tag>
        <tag>grad</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令记录自己常用的命令。 1️⃣ls：显式当前目录下的文件和目录 -a 包括隐藏文件 -h 将文件的容量以易读方式列出（配合-s使用） -s 以块数形式显示每个文件分配的尺寸 -l 以较长格式列出信息，可以直接写成 ll 2️⃣cd 到达指定地址 3️⃣kill 杀死程序 -l 信息编号。当l=9时，无条件终止，其他信号可能忽略 killall -u 杀死该用户全部进程 4️⃣ps 报告当前系统的进程状态 -a 所有 -p 指定程序 -u 指定用户 -x 列出该用户的进程的详细信息(我的理解应该是) 如： 5️⃣htop 比top更优，交互更好，同时可以直观看到资源占用情况基本命令与top一致 6️⃣top：动态查看系统运行状态 -u 指定用户名 -p 指定进程 7️⃣nvidia-smi 查看显卡状态watch nvidia-smi 实时查看显卡状态，定时刷新 8️⃣tail 显示指定文件的末尾若干行 -f 显示文件最新追加的内容 -n 显示文件尾部n行内容 -c 显示文件尾部最后c个字符 如： 123tail file 显示最后10行tail -n +20 file 显示从第20行至末尾tail -c 10 file 显示文件file的最后10个字符 ------- 9️⃣echo 用于打印指定的字符串 🔟which 用于查找并显示给定命令的绝对路径，which指令会在环境变量$PATH设置的目录里查找符合条件的文件。使用which命令，可以看到某个系统命令是否存在，以及执行的是哪个位置的命令。如： 1️⃣1️⃣nohup 将程序以忽略挂起信号的方式运行，经常用于在服务器跑代码如：1nohup python xxx.py &gt;output.txt 2&gt;&amp;1 &amp; 即，将输出重定向到output.txt ；最后一个&amp;表示后台挂起 1️⃣2️⃣cp 复制文件 cp [文件] [目标文件夹] -r 递归复制，用于目录的复制 1️⃣3️⃣mv 移动文件、目录或更名 mv [文件/文件夹] [文件夹] -f 强制，当目标文件存在，直接覆盖 -i 会询问 1️⃣4️⃣rm 删除文件或目录 -f 强制删除 -r 递归删除，用于目录删除 1️⃣5️⃣file 用于判断文件的基本数据如： 1️⃣6️⃣tar 对文件打包/压缩 -t 查看打包文件的内容含有哪些文件名 -x 解压缩 -c 新建打包文件 -C 指定压缩/解压目录 -v 解压/压缩过程中将处理的文件名显示出来常用的： 123压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称查询：tar -jtv -f filename.tar.bz2解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 1️⃣7️⃣wc word count 统计文件内容信息，如行数、字符数 -l 显示文件行数 -c 显示字节数 -m 显示字符数 -w 显示字数 字被定义为由空白、跳格、换行字符分隔的字符串 -L 显示最长行的长度 不加参数，所有的都显示，依次是行数、单词数、字节数、文件名 1️⃣8️⃣df 显示磁盘相关信息 -h 以可读性较高的方式显示信息 1️⃣9️⃣scp 服务器之间的文件复制 如: 1scp -r /test1 zhlin@123.12.1.12:/home/zhlin ✨快捷键Ctrl+a 跳到行首Ctrl+c 退出当前进程Ctrl+e 跳到页尾Ctrl+k 删除当前光标后面的文字Ctrl+l 清屏，等价于clearCtrl+r 搜索之前打过的命令Ctrl+u 删除当前光标前面的文字✨Ctrl+左右键 单词之间跳转 在Mac上可以使用option+左右键Ctrl+y 进行恢复删除Ctrl+z 将当前进程转到后台，使用fg恢复 Referencehttps://blog.csdn.net/leo_618/article/details/53003111 ———-持续更新———-]]></content>
      <tags>
        <tag>技巧</tag>
        <tag>Linux</tag>
        <tag>碎片知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个关于yield的重新认识]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8Eyield%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[今天遇到了一个神奇的”bug”，让我对yield的理解更深一步。 这是一个函数，我本来打算试着print一下line内部的格式和内容。 这是调用的主函数： 结果跑出的结果是： ？？？ 我尝试在函数的开头添加print： 结果仍然没有任何的输出。 我试着在main函数添加print： 结果： 也就是说，根本没有进入到get_dataset_from_txt函数啊。 我以为是pycharm的问题还重启了一遍，然而并没有任何作用。问了其他人，他们也觉得很神奇。最后一个同学看了一下函数，发现了问题所在：yield 我突然想起来，yield返回的是一个generator，只有在对generator进行遍历时，才会开始运行… 于是，我试着这么写，试着对generator遍历： 虽然报错了，但函数终于是进去了… 结论：有yield的函数会返回一个generator，当对其进行遍历时，函数才会开始运行。]]></content>
      <tags>
        <tag>遇到的问题</tag>
        <tag>Python</tag>
        <tag>yield</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段记录2]]></title>
    <url>%2F2018%2F07%2F29%2F%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%2F%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%88%86%E4%BA%AB2%2F</url>
    <content type="text"><![CDATA[本周主要看了AllenNLP/ELMO的代码，但并没有找到很多可复用的代码。本周也没有比较有意义的代码。 1️⃣get_time_diff获取已使用的时间123456789import timefrom datetime import timedeltastart_time=time.time()def get_time_dif(start_time): """获取已使用时间""" end_time = time.time() time_dif = end_time - start_time return timedelta(seconds=int(round(time_dif))) 2️⃣parser使用12345678parser = argparse.ArgumentParser()parser.add_argument('--save_dir', help='Location of checkpoint files')parser.add_argument('--vocab_file', help='Vocabulary file')parser.add_argument('--train_prefix', help='Prefix for train files')args = parser.parse_args() main(args) #使用]]></content>
      <tags>
        <tag>code snippets</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周碎片知识1]]></title>
    <url>%2F2018%2F07%2F29%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%AF%8F%E5%91%A8%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%861%2F</url>
    <content type="text"><![CDATA[1️⃣[Python]assert用法： assert expression等价于if not expression: raise AssertionError 2️⃣[Pytorch]Pytorch view：创建一个新的tensor，但他们的data是共享的。 3️⃣[Pytorch]在Pytorch中，embedding的index是不能requires_grad=True的，否则会出错。https://github.com/pytorch/pytorch/issues/7021 之前看过一份代码，设置volatile=false但没有出错，是因为在Pytorch0.4之后volatile已经被弃用了，因此volatile=false不起作用，而默认requires_grad=false 4️⃣[Pytorch]在Pytorch中，nn.Linear(self.hidden_dim,self.vocab_size)的维度是vocab_sizehidden_dim，之前居然没有注意到这个问题。因为nn.Linear的*第一个参数表示输入维度，第二个参数表示输出维度 5️⃣[Pytorch]Pytorch中，使用view一般来说必须要用 .contiguous()。也即： 1batch.view(batch_size, -1).t().contiguous() contiguous()的官方解释：https://discuss.pytorch.org/t/runtimeerror-input-is-not-contiguous/930 It means that your tensor is not a single block of memory, but a block with holes. view can be only used with contiguous tensors, so if you need to use it here, just call .contiguous() before. 也就是说，contiguous会将数据存到一个连续的空间内（block）。 6️⃣[Pytorch]调用Cross_entropy时，Pytorch会帮助你加log和softmax。 7️⃣[Paper]Sliced_RNN 将RNN分块以提高并行性，甚至每层的RNN都可以不一样，达到抽取不同程度的抽象语义信息的目的。实验证明，在不同任务上都有一定的提升，但速度的提升很大。 8️⃣[Tf-idf]计算词语对于句子的重要程度 https://zh.wikipedia.org/wiki/Tf-idf tf是词频，idf是逆向文件频率。也即如果词在该句出现的次数越多，在所有文本的出现次数越少，则词对于句子的重要程度越高。 9️⃣[Numpy]在Numpy中，一个列表虽然是横着表示的，但它是列向量。我之前居然没有注意到这个问题。]]></content>
      <tags>
        <tag>碎片知识</tag>
        <tag>Python</tag>
        <tag>Pytorch</tag>
        <tag>Paper</tag>
        <tag>Tf-idf</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac配置复旦有线网]]></title>
    <url>%2F2018%2F07%2F29%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2FMac%E9%85%8D%E7%BD%AE%E5%A4%8D%E6%97%A6%E6%9C%89%E7%BA%BF%E7%BD%91%2F</url>
    <content type="text"><![CDATA[配置ip、子网掩码、DNS、路由器有线似乎不支持DHCP，因此只好自己设置。首先连接上有线，将配置iPv4选为手动。问实验室的学长具体的ip地址、子网掩码、路由器、DNS服务器。其中ip地址最后三位要自己设定，只要不和其他人冲突就好。 手动认证到认证平台，下载Mac客户端，其实就是一个.sh文件：http://10.108.255.249/srun_portal_pc.php?ac_id=1&amp;&amp;phone=1 然后，打开文件配置用户名密码，注意到等号后面要有双引号： 保存并放入终端运行，接下来就可以使用有线网了。 其他似乎，每次重新连接都要这样配置，我没有试过不清楚；有线网好像也没有比无线网快多少，但应该会稳定一些。]]></content>
      <tags>
        <tag>网络</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh快速登录配置]]></title>
    <url>%2F2018%2F07%2F29%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2Fssh%E5%BF%AB%E9%80%9F%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Motivation分配了服务器之后，每次要ssh进入都很麻烦：ssh user_name@ip_address 然后还要输入密码。 特别是如果分配了多个服务器，那有时候还容易忘记ip地址。因此如果能够一条命令就进入服务器能够减少麻烦。主要有三点： 创建rsa key 上传public key到服务器 设置alias 配置创建rsa key在终端输入命令： 1ssh-keygen -t rsa 当然如果以前有创建过的可以不用。 结果： 上传public key到服务器使用命令：1ssh-copy-id -i ~/.ssh/id_rsa.pub user@127.0.0.1 输入密码即可 结果： 设置alias完成以上步骤就可以不输入密码登录，但还是需要输入ip地址和用户名，为了更简化操作，给命令起个别名。需要配置 .bash_profile文件。输入命令: 1vim ~/.bash_profile 在文件后面添加以下文字： 123# alias alias ssh×××=&quot;ssh user_name@ip_address&quot;alias ssh×××=&quot;ssh user_name@ip_address&quot; 其中 ×××是你自己起的名字，可以是服务器的名字，user_name和ip_address是自己服务器的用户名和地址。保存更改退出。 然后还要使其生效: 1source ~/.bash_profile 这样，输入别名，就可以直接登录了： 参考https://www.jianshu.com/p/66d658c7cb9e]]></content>
      <tags>
        <tag>配置</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于困惑度]]></title>
    <url>%2F2018%2F07%2F29%2F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%85%B3%E4%BA%8E%E5%9B%B0%E6%83%91%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[前几天在写新手任务task3的时候，参考了Pytorch官方example的word language model，官方example在训练过程中计算困惑度是这样的： 1math.exp(cur_loss) 其中，cur_loss表示交叉熵的loss，即 $-P(\hat{x})logP(x)$，$\hat{x}$表示ground truth。 然而，在查阅了困惑度相关资料后，我发现，困惑度的定义是这样的： \begin{aligned} PP(S)= &{P(w_{1}w_{2}...w_{N})}^{-\frac{1}{N}} \\ = &\sqrt[N]{\frac{1}{p(w_1 w_2 ... w_N)}} \\ = & \sqrt[N]{\prod_{i=1}^{N}{\frac{1}{p(w_i|(w_1 w_2... w_{i-1})}} } \end{aligned}这是另一种形式: \begin{aligned} Perplexity (W)=& 2^{H(W)} \\ = & {P(w_{1}w_{2}...w_{N})}^{-\frac{1}{N}} \\ = & \sqrt[N]{\frac{1}{p(w_1 w_2 ... w_N)}} \\ = & \sqrt[N]{\prod_{i=1}^{N}{\frac{1}{p(w_i|(w_1 w_2... w_{i-1})}} } \end{aligned}可以看到，二者本质是一样的。 那么，为什么在代码中以e为底去计算困惑度，而不是2呢? 实际上，是因为在上述公式中，log是以2为底的，但在Pytorch中，log默认是以e为底的。因此在代码中，需要用e作为指数的底来还原成困惑度的原本形式： \begin{aligned} \sqrt[N]{\prod_{i=1}^{N}{\frac{1}{p(w_i|(w_1 w_2... w_{i-1})}} } \end{aligned}最后这是perplexity的数学推导：https://www.zhihu.com/question/58482430]]></content>
      <tags>
        <tag>困惑度</tag>
        <tag>perplexity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词2]]></title>
    <url>%2F2018%2F07%2F29%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D2%2F</url>
    <content type="text"><![CDATA[本周的诗词有两篇是已经背过的，权当是复习了一遍。 1️⃣ 下终南山过斛斯山人宿置酒[唐] 李白暮从碧山下，山月随人归。却顾所来径，苍苍横翠微。相携及田家，童稚开荆扉。绿竹入幽径，青萝拂行衣。欢言得所憩，美酒聊共挥。长歌吟松风，曲尽河星稀。我醉君复乐，陶然共忘机。 http://m.xichuangzhu.com/work/57b900307db2a20054269a2a 2️⃣ 逢入京使[唐] 岑参故园东望路漫漫，双袖龙钟泪不乾。马上相逢无纸笔，凭君传语报平安。 http://m.xichuangzhu.com/work/57b92218df0eea006335f923 3️⃣ 念奴娇·赤壁怀古[宋] 苏轼大江东去，浪淘尽、千古风流人物。故垒西边，人道是、三国周郎赤壁。乱石穿空，惊涛拍岸，卷起千堆雪。江山如画，一时多少豪杰。遥想公瑾当年，小乔初嫁了，雄姿英发。羽扇纶巾，谈笑间，樯橹灰飞烟灭。故国神游，多情应笑我，早生华发。人生如梦，一尊还酹江月。 http://m.xichuangzhu.com/work/57b8bda2df0eea006333ecd2]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段记录1]]></title>
    <url>%2F2018%2F07%2F23%2F%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%2F%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%88%86%E4%BA%AB1%2F</url>
    <content type="text"><![CDATA[1️⃣ get_batch注意到shuffle的标准做法 123456789101112def get_batch(self,data,batch_size=32,is_shuffle): N=len(data) #获得数据的长度 if is_shuffle is True: r=random.Random() r.seed() r.shuffle(data) #如果is_shuffle为真则打乱 #开始获得batch，使用[ for in ] batch=[data[k:k+batch_size] for k in range(0,N,batch_size)] if N%batch_size!=0: #处理不整除问题，如果有显式要求丢掉则不需要处理，这里默认处理 remainder=N-N%batch_size #剩下的部分 batch.append(data[temp:N]) return batch 2️⃣使用gensim将GloVe读入实际上这份代码有点问题，在使用过程中，发现glove文件需要放在gensim的文件夹下才能被读到(7.20 updated,应该使用绝对地址)，并不好。 教程地址：gensim: scripts.glove2word2vec – Convert glove format to word2vec123456789101112131415161718#1. 使用gensim读入word2vecmodel = gensim.models.KeyedVectors.load_word2vec_format( fname='GoogleNews-vectors-negative300-SLIM.bin', binary=True)words = model.vocab #获得词表vector= model[word] #word是words里面的元素#2. 使用gensim读入glovefrom gensim.models import KeyedVectorsfrom gensim.test.utils import datapath, get_tmpfilefrom gensim.scripts.glove2word2vec import glove2word2vecglove_file=datapath('glove.txt') #最好使用绝对地址tmp_file=get_tmpfile('word2vec.txt')glove2word2vec(glove_file,tmp_file)model=KeyedVectors.load_word2vec_format(tmp_file)#接下来使用的方法是一样的 3️⃣data_split方法1234567891011121314151617181920def data_split(seed=1, proportion=0.7): data = list(iter_corpus()) ids = list(range(len(data))) N = int(len(ids) * proportion) # number of training data rng = random.Random(seed) rng.shuffle(ids) test_ids = set(ids[N:]) train_data = [] test_data = [] for x in data: if x[1] in test_ids: # x[1]: sentence id test_data.append(x) else: train_data.append(x) return train_data, test_data 4️⃣对string预处理123456789101112131415161718def clean_str(string): string = re.sub(r"[^A-Za-z0-9()!?\'\`]", "", string) string = re.sub(r"\'s", " \'s", string) string = re.sub(r"\'m", " \'m", string) string = re.sub(r"\'ve", " \'ve", string) string = re.sub(r"n\'t", " n\'t", string) string = re.sub(r"\'re", " \'re", string) string = re.sub(r"\'d", " \'d", string) string = re.sub(r"\'ll", " \'ll", string) string = re.sub(r",", " , ", string) string = re.sub(r"!", " ! ", string) string = re.sub(r"\(", " \( ", string) string = re.sub(r"\)", " \) ", string) string = re.sub(r"\?", " \? ", string) string = re.sub(r"\s&#123;2,&#125;", " ", string) string = re.sub(r"\@.*?[\s\n]", "", string) string = re.sub(r"https*://.+[\s]", "", string) return string.strip().lower() 5️⃣collate_fn(batch）重写collate_fn组建mini-batch，在NLP中常用，句子的不等长性123456789101112131415161718192021222324252627def collate_fn(batch): # rewrite collate_fn to form a mini-batch lengths = np.array([len(data['sentence']) for data in batch]) sorted_index = np.argsort(-lengths) lengths = lengths[sorted_index] # descend order max_length = lengths[0] batch_size = len(batch) sentence_tensor = torch.LongTensor(batch_size, int(max_length)).zero_() for i, index in enumerate(sorted_index): sentence_tensor[i][:lengths[i]] = torch.LongTensor(batch[index]['sentence'][:max_length]) sentiments = torch.autograd.Variable(torch.LongTensor([batch[i]['sentiment'] for i in sorted_index])) if config.use_cuda: packed_sequences = torch.nn.utils.rnn.pack_padded_sequence(Variable(sentence_tensor.t()).cuda(), lengths) #remember to transpose sentiments = sentiments.cuda() else: packed_sequences = torch.nn.utils.rnn.pack_padded_sequence(Variable(sentence_tensor.t()),lengths) # remember to transpose return &#123;'sentence': packed_sequences, 'sentiment': sentiments&#125;## 重写collate_fn(batch)以用于dataloader使用，使用方法如下：train_dataloader=DataLoader(train_data,batch_size=32,shuffle=True,collate_fn=collate_fn)​## 其中，train_dataloader可循环遍历​​。for data in train_dataloader: ... 6️⃣使用yield获得数据的generatoryield的用法123456789101112131415def get_dataset(txt_file): # return generator with open(txt_file,'r') as f: for line in f: if len(line.strip())==0: continue sentence=list(line.strip())+['&lt;eos&gt;'] yield sentence #在使用的时候：dataset=get_dataset(txt_file)for d in dataset: pass#如果需要还可以改成list形式dataset=list(get_dataset(txt_file)) 7️⃣动态创建RNN实例根据rnn_type动态创建对象实例，使用了getattr123# rnn in ['GRU','LSTM','RNN']self.rnn = getattr(nn, self.rnn_type)(self.embedding_dim, self.hidden_dim, self.num_layers, dropout=self.dropout)]]></content>
      <tags>
        <tag>code snippets</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周诗词1]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%AF%97%E8%AF%8D%26%E5%8F%A5%2F%E6%AF%8F%E5%91%A8%E8%AF%97%E8%AF%8D1%2F</url>
    <content type="text"><![CDATA[本周背了四篇。 1️⃣ 临江仙·夜归临皋[宋] 苏轼夜饮东坡醒复醉，归来彷彿三更。家童鼻息已雷鸣，敲门都不应，倚杖听江声。长恨此身非我有，何时忘却营营？夜阑风静縠纹平，小舟从此逝，江海寄馀生。 縠（hú）纹皋（gao）http://m.xichuangzhu.com/work/57ae79400a2b580063150e39 2️⃣ 蝶恋花·阅尽天涯离别苦[清] 王国维阅尽天涯离别苦。不道归来，零落花如许。花底相看无一语，绿窗春与天俱莫。待把相思灯下诉。一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。 http://m.xichuangzhu.com/work/57b8ef70128fe10054c91d17 3️⃣ 送友人[唐] 李白青山横北郭，白水绕东城。此地一为别，孤蓬万里征。浮云游子意，落日故人情。挥手自兹去，萧萧班马鸣。 http://m.xichuangzhu.com/work/57b8facfd342d3005ac6ffb4 4️⃣ 黄鹤楼送孟浩然之广陵[唐] 李白故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，唯见长江天际流。 http://m.xichuangzhu.com/work/57b8f306128fe10054c92fb8]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>诗词分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装conda错误]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2F%E5%AE%89%E8%A3%85conda%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[在服务器上安装conda的时候，一开始使用了pip安装pip install conda在安装好conda之后想要使用conda命令，出现： ERROR: The install method you used for conda—probably either pip install conda or easy_install conda—is not compatible with using conda as an application. If your intention is to install conda as a standalone application, currently supported install methods include the Anaconda installer and the miniconda installer. You can download the miniconda installer from https://conda.io/miniconda.html. 然后到官网下载.sh文件并bash安装，仍然没有解决该问题；接着尝试pip uninstall conda，出现 最后在查阅了网上之后，使用 which conda找到conda的地址，并删除rm ××× 最后重新bash安装即可。]]></content>
      <tags>
        <tag>杂七杂八</tag>
        <tag>conda</tag>
        <tag>遇到的问题</tag>
      </tags>
  </entry>
</search>
